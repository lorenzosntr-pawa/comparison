---
phase: 96-navigation-overhaul
plan: 96-01-FIX
type: fix
---

<objective>
Fix 4 UAT issues from plan 96-01.

Source: 96-01-ISSUES.md
Priority: 0 critical, 4 major, 0 minor
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/96-navigation-overhaul/96-01-ISSUES.md

**Original plan for reference:**
@.planning/phases/96-navigation-overhaul/96-01-PLAN.md

**Current sidebar implementation:**
@web/src/components/layout/app-sidebar.tsx

**Hooks to use:**
- `useHealth` - returns `{ status, database, platforms }` where `database` is 'connected' | 'disconnected'
- `useSchedulerStatus` - returns `{ running, paused, jobs }` where `jobs[0].next_run` has countdown timestamp
- `useActiveScrapesObserver` - returns `{ activeScrapeId, isObserving, overallPhase, platformProgress }`
- `api.triggerScrape()` - triggers manual scrape run

**WebSocket state:**
- `useWebSocket` hook's `state` property shows: 'connecting' | 'connected' | 'disconnected' | 'error'
- The app-level WebSocket is used via `useOddsUpdates` in App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix health indicator consistency (UAT-001)</name>
  <files>web/src/components/layout/app-sidebar.tsx</files>
  <action>
Fix the database health indicator to match Dashboard behavior:

1. **Change dbHealthy check** (line 37):
   - Current: `const dbHealthy = health?.status === 'healthy'`
   - Change to: `const dbHealthy = health?.database === 'connected'`
   - This matches PlatformHealth component which checks `data?.database === 'connected'`

2. **Add WebSocket connection indicator**:
   - Import `useWebSocket` from `@/hooks/use-websocket`
   - Add call: `const ws = useWebSocket({ topics: ['odds_updates'], enabled: false })` just to get state
   - Actually, simpler: import the global WebSocket state. Check if App.tsx exposes it or if there's a shared hook.

   Alternative approach: The useOddsUpdates hook in App.tsx uses WebSocket internally. But we need connection status.
   Better: Create a minimal WebSocket connection check using the existing useWebSocket hook:
   - Add `const wsState = useWebSocket({ enabled: true })` to get `wsState.state`
   - Actually this will create a duplicate connection. Instead, just show WS status based on whether active scrape observation is connected.

   Simplest fix: Use the existing hooks that already connect to WebSocket:
   - The sidebar already imports `useActiveScrapesObserver` (will add in Task 2)
   - Add its `connectionState` to the status display

   For now in Task 1: Just fix the DB health check. WS status will be added in Task 2 with the scrape observer.
  </action>
  <verify>`npm run build` passes, sidebar DB health matches Dashboard when both are viewed</verify>
  <done>Database health indicator uses same check as Dashboard (database === 'connected')</done>
</task>

<task type="auto">
  <name>Task 2: Add current scrape run info and WS status (UAT-001, UAT-002)</name>
  <files>web/src/components/layout/app-sidebar.tsx</files>
  <action>
Add active scrape progress and WebSocket connection status to sidebar:

1. **Import `useActiveScrapesObserver`**:
   - Add to imports: `import { useActiveScrapesObserver } from '@/features/dashboard/hooks'`

2. **Use the hook**:
   - Add call in component: `const { activeScrapeId, isObserving, overallPhase, connectionState } = useActiveScrapesObserver()`

3. **Add WebSocket indicator to System health section** (after Scheduler row):
   - Add row showing WebSocket status
   - Use `connectionState` which can be 'connecting' | 'connected' | 'disconnected' | 'error'
   - Show green "Connected" if connected, yellow "Connecting" if connecting, red "Disconnected" if disconnected/error

4. **Add Active Scrape section** (after Last Scrape section, conditional on activeScrapeId):
   - Show when `activeScrapeId !== null`
   - Display "Scraping..." with phase name from `overallPhase`
   - Optionally show progress if available
   - Use blue color for "In Progress" indicator
  </action>
  <verify>`npm run build` passes, trigger a scrape and verify sidebar shows active scrape status</verify>
  <done>Sidebar shows WebSocket connection status and active scrape progress when running</done>
</task>

<task type="auto">
  <name>Task 3: Add manual scrape button (UAT-003)</name>
  <files>web/src/components/layout/app-sidebar.tsx</files>
  <action>
Add a button to trigger manual scrape from sidebar:

1. **Import needed components and hooks**:
   - Add `Button` from `@/components/ui/button`
   - Add `useMutation, useQueryClient` from `@tanstack/react-query`
   - Add `Play` icon from `lucide-react`

2. **Create mutation for triggering scrape**:
   ```typescript
   const queryClient = useQueryClient()
   const triggerScrape = useMutation({
     mutationFn: () => api.triggerScrape(),
     onSuccess: () => {
       queryClient.invalidateQueries({ queryKey: ['scrapeRuns'] })
     },
   })
   ```

3. **Add scrape button** in the Status section (after the Last Scrape info):
   - Small compact button with Play icon
   - Disabled when `activeScrapeId !== null` (scrape already running)
   - Disabled when `triggerScrape.isPending`
   - Show loading state when pending
   - Button text: just icon when collapsed, "Run Scrape" when expanded

4. **Styling**:
   - Use `size="sm"` and `variant="outline"` for compact look
   - Full width in the Status section
  </action>
  <verify>`npm run build` passes, click button and verify scrape triggers</verify>
  <done>Sidebar has functional manual scrape button that triggers scrape when clicked</done>
</task>

<task type="auto">
  <name>Task 4: Add countdown to next scrape (UAT-004)</name>
  <files>web/src/components/layout/app-sidebar.tsx</files>
  <action>
Add countdown display showing time until next scheduled scrape:

1. **Access next run time**:
   - The `scheduler` data already has `jobs` array
   - Get next run: `const nextRun = scheduler?.jobs?.[0]?.next_run`
   - This is an ISO timestamp string

2. **Create countdown state**:
   - Add `useState` for countdown string
   - Add `useEffect` with interval to update countdown every second
   - Calculate remaining time: `differenceInSeconds(new Date(nextRun), new Date())`
   - Format as "Xm Ys" or "X min" depending on time remaining
   - Import `differenceInSeconds` from `date-fns` (already imported formatDistanceToNow)

3. **Display countdown** in the Status section:
   - Add row "Next Scrape" with the countdown
   - Show only when scheduler is running and not paused
   - Show "Paused" if scheduler is paused
   - Show "-" if no next run scheduled

4. **Cleanup**:
   - Clear interval on unmount
   - Clear interval when next_run changes
  </action>
  <verify>`npm run build` passes, verify countdown updates every second and shows accurate time to next scrape</verify>
  <done>Sidebar shows countdown timer to next scheduled scrape that updates in real-time</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Database health indicator matches Dashboard behavior
- [ ] WebSocket connection status is visible in sidebar
- [ ] Active scrape progress shows when scrape is running
- [ ] Manual scrape button triggers scrape successfully
- [ ] Countdown to next scrape displays and updates in real-time
- [ ] `npm run build` succeeds without errors
- [ ] All UAT issues from 96-01-ISSUES.md addressed
</verification>

<success_criteria>
- All 4 UAT issues from 96-01-ISSUES.md addressed
- Build passes
- Ready for re-verification with /gsd:verify-work
</success_criteria>

<output>
After completion, create `.planning/phases/96-navigation-overhaul/96-01-FIX-SUMMARY.md`
</output>
