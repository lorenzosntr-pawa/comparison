---
phase: 57-websocket-infrastructure
plan: 01
type: execute
---

<objective>
Create WebSocket connection manager and endpoint for real-time client communication.

Purpose: Establish the WebSocket server infrastructure that Phase 57-02 and 57-03 will use to broadcast scrape progress and odds changes. This runs alongside existing SSE — no breaking changes.
Output: Working WebSocket endpoint at /api/ws with connection lifecycle management and topic-based subscriptions.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (dependency graph):
@.planning/phases/54-in-memory-cache/54-01-SUMMARY.md
@.planning/phases/56-concurrency-tuning/56-01-SUMMARY.md

# Key source files:
@src/api/app.py
@src/scraping/broadcaster.py
@src/caching/odds_cache.py
@src/scraping/schemas.py

**Tech stack available:** FastAPI (Starlette WebSocket built-in), asyncio, structlog, Pydantic v2
**Established patterns:** app.state for shared services, asynccontextmanager lifespan, structlog logging, frozen dataclasses
**Constraining decisions:**
- WebSocket must run alongside SSE initially — no breaking changes during migration (STATE.md)
- OddsCache on app.state is the source of truth for current odds
- ProgressBroadcaster pub/sub pattern for scrape progress
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ConnectionManager with topic-based subscriptions</name>
  <files>src/api/websocket/__init__.py, src/api/websocket/manager.py</files>
  <action>
Create `src/api/websocket/` package with ConnectionManager class in `manager.py`.

ConnectionManager design:
- `_connections: dict[WebSocket, set[str]]` — maps each WebSocket to its subscribed topics
- `_topics: dict[str, set[WebSocket]]` — reverse index: topic → set of subscribers
- Predefined topics: "scrape_progress", "odds_updates" (extensible)
- Methods:
  - `async connect(websocket: WebSocket, topics: list[str] | None = None)` — accept connection, register with default topics (all topics if None)
  - `disconnect(websocket: WebSocket)` — remove from all data structures (no await needed — just dict cleanup)
  - `async broadcast(message: dict, topic: str)` — send JSON to all subscribers of a topic. Use `websocket.send_json()`. On send failure (WebSocketDisconnect, RuntimeError), silently remove the dead connection — do NOT re-raise. Collect dead connections, clean up after iteration (avoid mutating dict during iteration).
  - `async broadcast_all(message: dict)` — send to every connected client regardless of topic
  - `@property active_count -> int` — number of connected clients
  - `@property topic_counts -> dict[str, int]` — subscriber count per topic

Use asyncio.Lock for `connect`/`disconnect` to prevent race conditions during concurrent connect/disconnect. The `broadcast` method does NOT need the lock — it iterates a snapshot of the subscribers set (`set(self._topics.get(topic, set()))`) to avoid mutation during iteration.

Log connect/disconnect events with structlog: `ws.connect` (topics, total_connections), `ws.disconnect` (total_connections).

`__init__.py` exports: `ConnectionManager`.

Do NOT use starlette.websockets.WebSocketState — just catch exceptions on send. Do NOT create a background heartbeat task in the manager — the endpoint handles ping/pong.
  </action>
  <verify>
`python -c "from src.api.websocket import ConnectionManager; m = ConnectionManager(); print('OK:', m.active_count)"` prints "OK: 0"
  </verify>
  <done>ConnectionManager class importable, has connect/disconnect/broadcast/broadcast_all methods, topic-based subscription tracking, structlog logging, no import errors</done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket endpoint and register in app lifespan</name>
  <files>src/api/routes/ws.py, src/api/app.py</files>
  <action>
**Create `src/api/routes/ws.py`:**

WebSocket endpoint at path `/ws` (will be mounted at `/api/ws` via router prefix).

Use `APIRouter` with `tags=["websocket"]`. The endpoint:

```
@router.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
```

Lifecycle:
1. Accept connection
2. Parse optional query params: `?topics=scrape_progress,odds_updates` (comma-separated). Default: subscribe to all topics.
3. Get ConnectionManager from `websocket.app.state.ws_manager`
4. Call `manager.connect(websocket, topics)`
5. Send connection acknowledgment message: `{"type": "connection_ack", "topics": [...subscribed_topics], "timestamp": utcnow_iso}`
6. Enter receive loop:
   - `await websocket.receive_json()` — handle client messages
   - Client can send `{"type": "subscribe", "topics": ["odds_updates"]}` or `{"type": "unsubscribe", "topics": ["scrape_progress"]}` — add/remove topic subscriptions dynamically
   - Client can send `{"type": "ping"}` — respond with `{"type": "pong", "timestamp": utcnow_iso}`
   - Unknown message types: ignore (log at debug level)
7. On WebSocketDisconnect exception: call `manager.disconnect(websocket)` — clean exit
8. On any other exception: log error, call `manager.disconnect(websocket)`

Use a try/except/finally pattern. The `finally` block ensures disconnect always runs.

Do NOT use `receive_text()` — use `receive_json()` for structured messages. Catch `json.JSONDecodeError` from malformed messages and log + ignore.

**Modify `src/api/app.py`:**

1. Import: `from src.api.websocket import ConnectionManager` and `from src.api.routes.ws import router as ws_router`
2. In `lifespan()`, after write_queue setup (around line 152), create ConnectionManager and store on app.state:
   ```python
   ws_manager = ConnectionManager()
   app.state.ws_manager = ws_manager
   ```
   Log: `log.info("ws_manager_ready")`
3. In `create_app()`, include the ws_router: `app.include_router(ws_router, prefix="/api")`
4. No shutdown cleanup needed for ConnectionManager — connections close naturally when the server stops.
  </action>
  <verify>
Start the dev server and test with a WebSocket client:
```bash
python -c "
import asyncio, websockets, json
async def test():
    async with websockets.connect('ws://localhost:8000/api/ws?topics=scrape_progress,odds_updates') as ws:
        ack = json.loads(await ws.recv())
        print('ACK:', ack)
        assert ack['type'] == 'connection_ack'
        assert set(ack['topics']) == {'scrape_progress', 'odds_updates'}
        await ws.send(json.dumps({'type': 'ping'}))
        pong = json.loads(await ws.recv())
        print('PONG:', pong)
        assert pong['type'] == 'pong'
        print('ALL TESTS PASSED')
asyncio.run(test())
"
```
If websockets library not installed, use: `pip install websockets` first.
  </verify>
  <done>WebSocket endpoint accepts connections at /api/ws, sends connection_ack with subscribed topics, responds to ping with pong, handles subscribe/unsubscribe messages, cleans up on disconnect, ConnectionManager accessible via app.state.ws_manager</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.api.websocket import ConnectionManager"` succeeds
- [ ] Dev server starts without import errors
- [ ] WebSocket connection at ws://localhost:8000/api/ws succeeds
- [ ] connection_ack message received with correct topics
- [ ] ping/pong round-trip works
- [ ] Disconnect is logged and connection cleaned up
- [ ] Existing SSE endpoints still work (no regression)
</verification>

<success_criteria>

- ConnectionManager class with topic-based pub/sub
- WebSocket endpoint at /api/ws with connection lifecycle
- ConnectionManager stored on app.state.ws_manager
- No changes to existing SSE infrastructure
- All verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/57-websocket-infrastructure/57-01-SUMMARY.md`
</output>
