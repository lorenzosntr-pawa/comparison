---
phase: 57-websocket-infrastructure
plan: 03
type: execute
---

<objective>
Add odds change notifications via WebSocket so connected clients receive real-time updates when odds data changes.

Purpose: Replace the 60-second polling interval with instant push notifications when odds are updated in the cache. This is the key new capability WebSocket enables beyond SSE (which only streams scrape progress, not data changes).
Output: Connected WebSocket clients subscribed to "odds_updates" receive notifications with event_ids whenever the OddsCache is updated with new or changed odds.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/57-websocket-infrastructure/57-01-SUMMARY.md
@.planning/phases/57-websocket-infrastructure/57-02-SUMMARY.md

# Key source files:
@src/caching/odds_cache.py
@src/api/websocket/manager.py
@src/api/websocket/messages.py
@src/scraping/event_coordinator.py
@src/api/app.py

**Tech stack available:** FastAPI WebSocket, asyncio, structlog, frozen dataclasses
**Established patterns:** Cache-before-persist (cache updated for ALL data before write queue), OddsCache on app.state, ConnectionManager on app.state, scrape_progress_message pattern
**Constraining decisions:**
- Cache updated immediately for ALL data (changed + unchanged) before async write queue enqueue (Phase 55 decision)
- OddsCache put_betpawa_snapshot/put_competitor_snapshot are the mutation points
- Notification should be lightweight (event_ids only) — frontend refetches from cache-first API
- Keep OddsCache simple — callback mechanism, not event emitter
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add change notification callback to OddsCache</name>
  <files>src/caching/odds_cache.py</files>
  <action>
Add an optional callback mechanism to OddsCache that fires when odds data is updated.

Modifications to OddsCache class:

1. Add `_on_update_callbacks: list[Callable]` in `__init__`:
   ```python
   self._on_update_callbacks: list = []
   ```

2. Add registration method:
   ```python
   def on_update(self, callback: Callable[[list[int], str], None]) -> None:
       """Register a callback for odds updates.

       Callback signature: (event_ids: list[int], source: str) -> None
       - event_ids: list of event IDs that were updated
       - source: "betpawa", "sportybet", or "bet9ja"
       """
       self._on_update_callbacks.append(callback)
   ```

3. Add internal notification method:
   ```python
   def _notify_update(self, event_ids: list[int], source: str) -> None:
       """Fire all registered update callbacks."""
       for cb in self._on_update_callbacks:
           try:
               cb(event_ids, source)
           except Exception:
               logger.exception("cache.on_update.callback_error", source=source)
   ```

4. Modify `put_betpawa_snapshot()` to call `self._notify_update([event_id], "betpawa")` after the snapshot is stored.

5. Modify `put_competitor_snapshot()` to call `self._notify_update([event_id], source)` after the snapshot is stored.

Important design notes:
- The callback is synchronous (not async) because `put_betpawa_snapshot` and `put_competitor_snapshot` are sync methods (no await). The callback should be a thin wrapper that enqueues work for async processing — it must NOT do I/O or await.
- The callback receives `event_ids` as a list (not single int) for future batch notification support — the caller currently passes a single-element list.
- Error in one callback does NOT prevent other callbacks from running (try/except inside loop).
- Keep callback list simple — no deregistration needed (callbacks live for app lifetime).

Do NOT make put_betpawa_snapshot or put_competitor_snapshot async — that would break all callers.
  </action>
  <verify>
```bash
python -c "
from src.caching.odds_cache import OddsCache, CachedSnapshot, CachedMarket
from datetime import datetime

updates = []
cache = OddsCache()
cache.on_update(lambda event_ids, source: updates.append((event_ids, source)))

snap = CachedSnapshot(
    snapshot_id=1,
    event_id=100,
    bookmaker_id=1,
    captured_at=datetime.utcnow(),
    markets=(),
)
cache.put_betpawa_snapshot(100, 1, snap)
cache.put_competitor_snapshot(100, 'sportybet', snap)

assert len(updates) == 2
assert updates[0] == ([100], 'betpawa')
assert updates[1] == ([100], 'sportybet')
print('CALLBACK TESTS PASSED')
"
```
  </verify>
  <done>OddsCache has on_update() registration, put_betpawa_snapshot and put_competitor_snapshot fire callbacks, callback errors are caught and logged, callbacks are synchronous</done>
</task>

<task type="auto">
  <name>Task 2: Wire cache updates to WebSocket broadcasting</name>
  <files>src/api/app.py, src/api/websocket/bridge.py</files>
  <action>
Connect OddsCache change notifications to WebSocket broadcasting so clients subscribed to "odds_updates" receive real-time notifications.

**Add to `src/api/websocket/bridge.py`:**

Create a function that sets up the cache-to-WebSocket bridge:

```python
def create_cache_update_bridge(
    odds_cache: OddsCache,
    ws_manager: ConnectionManager,
) -> None:
```

This function:
1. Creates a batching mechanism to avoid sending one WebSocket message per individual snapshot update (during a scrape cycle, hundreds of updates happen rapidly). Use a simple approach:
   - Maintain a `pending: dict[str, set[int]]` mapping source → set of event_ids
   - Maintain an `asyncio.Event` or use `asyncio.get_event_loop().call_soon_threadsafe()` to schedule async broadcast from sync callback
2. Register a callback with `odds_cache.on_update()` that:
   - Adds event_ids to the pending set for the source
   - Schedules an async flush if not already scheduled

Actually, simpler approach — use `asyncio.get_event_loop()` to schedule the broadcast:

```python
def create_cache_update_bridge(
    odds_cache: OddsCache,
    ws_manager: ConnectionManager,
) -> None:
    """Register OddsCache callback that broadcasts updates via WebSocket."""
    log = structlog.get_logger("src.api.websocket.bridge")

    def on_cache_update(event_ids: list[int], source: str) -> None:
        """Sync callback — schedule async broadcast on the running loop."""
        try:
            loop = asyncio.get_running_loop()
            msg = odds_update_message(event_ids, source, len(event_ids))
            loop.create_task(_safe_broadcast(ws_manager, msg, log))
        except RuntimeError:
            # No running loop (shouldn't happen in FastAPI context)
            pass

    odds_cache.on_update(on_cache_update)
    log.info("ws.cache_bridge.registered")


async def _safe_broadcast(ws_manager: ConnectionManager, msg: dict, log) -> None:
    """Broadcast with error handling — never crash the caller."""
    try:
        await ws_manager.broadcast(msg, topic="odds_updates")
    except Exception:
        log.exception("ws.cache_bridge.broadcast_error")
```

This is simple, correct, and efficient:
- The sync callback uses `asyncio.get_running_loop()` to get the current event loop (FastAPI runs in asyncio)
- `loop.create_task()` schedules the async broadcast without blocking the sync caller
- Individual event updates → individual WebSocket messages (fine for the current scale; batching can be added later if needed)
- Error in broadcast never crashes the cache update path

**Modify `src/api/app.py`:**

In the `lifespan()` function, after both `odds_cache` and `ws_manager` are created (after line ~152), register the bridge:

```python
from src.api.websocket.bridge import create_cache_update_bridge
# ...
create_cache_update_bridge(odds_cache, ws_manager)
log.info("ws.cache_bridge.ready")
```

This must be placed AFTER both `odds_cache` and `ws_manager` are initialized but BEFORE `yield`.

**Update `src/api/websocket/__init__.py`** to export `create_cache_update_bridge`.

Do NOT add batching/debouncing in this plan — keep it simple. If WebSocket message volume becomes an issue, add batching in a follow-up. The current scale (~1,300 events across 3 platforms, 10 concurrent events per batch) produces manageable message volume.
  </action>
  <verify>
Start dev server. Open two terminals:

Terminal 1 — WebSocket client subscribing to odds_updates:
```bash
python -c "
import asyncio, websockets, json
async def listen():
    async with websockets.connect('ws://localhost:8000/api/ws?topics=odds_updates') as ws:
        ack = json.loads(await ws.recv())
        print('Connected:', ack)
        print('Waiting for odds updates...')
        count = 0
        while count < 5:
            msg = json.loads(await ws.recv())
            print(f'  [{msg[\"type\"]}] source={msg[\"data\"][\"source\"]} events={msg[\"data\"][\"event_ids\"]}')
            count += 1
        print(f'RECEIVED {count} ODDS UPDATE MESSAGES')
asyncio.run(listen())
"
```

Terminal 2 — Trigger a scrape:
```bash
curl http://localhost:8000/api/scrape/stream -N
```

Verify: WebSocket client receives odds_update messages as the scrape processes events and updates the cache.
  </verify>
  <done>OddsCache updates trigger WebSocket broadcasts to "odds_updates" subscribers, bridge registered during app startup, async broadcast scheduled from sync callback, error handling prevents cache path disruption, existing SSE and polling unaffected</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] OddsCache callback mechanism works (unit test)
- [ ] Cache-to-WebSocket bridge registered at startup (log message visible)
- [ ] odds_update messages received by WebSocket clients during scrape
- [ ] Errors in broadcast don't crash cache updates
- [ ] SSE endpoints still work (no regression)
- [ ] Polling-based TanStack Query still works (no regression)
- [ ] Server starts cleanly with all integrations
- [ ] Phase 57 complete — WebSocket infrastructure fully operational
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- OddsCache has change notification callback
- WebSocket clients receive odds_update messages in real time
- No regression on SSE or polling
- Phase 57 complete: WebSocket connection management, scrape progress broadcasting, and odds change notifications all operational
</success_criteria>

<output>
After completion, create `.planning/phases/57-websocket-infrastructure/57-03-SUMMARY.md`
</output>
