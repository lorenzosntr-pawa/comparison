---
phase: 04-event-matching
plan: 02
type: execute
---

<objective>
Create API endpoints for querying matched events with filtering, pagination, and unmatched event detection.

Purpose: Expose matched event data through REST endpoints for the frontend to consume.
Output: Events router with list, detail, and unmatched endpoints.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-event-matching/04-CONTEXT.md
@.planning/phases/04-event-matching/04-RESEARCH.md
@.planning/phases/04-event-matching/04-01-SUMMARY.md

**Key files:**
@src/matching/service.py
@src/matching/schemas.py
@src/api/routes/scrape.py
@src/api/routes/health.py
@src/db/models/event.py

**Tech stack available:** FastAPI, SQLAlchemy 2.0 async, Pydantic v2
**Established patterns:**
- Query param validation: ge=, le= for bounds checking
- `Depends(get_db)` for session injection
- Concurrent operations with `asyncio.gather`

**Constraining decisions:**
- Phase 3: Bookmaker records auto-created on first use
- Phase 4-01: EventMatchingService with upsert methods
- Phase 4-01: MatchedEvent, UnmatchedEvent schemas

**From CONTEXT.md:**
- Support queries by competition, time (upcoming/live/today), platform coverage
- Include unmatched events endpoint for monitoring data quality
- Partial matches are valid - show comparison with available odds
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create events router with list and detail endpoints</name>
  <files>src/api/routes/events.py</files>
  <action>
Create events router with list and detail endpoints.

**events.py implementation:**

1. `router = APIRouter(prefix="/events", tags=["events"])`

2. `GET /events/` - List matched events with filtering:
   - Query params:
     - `tournament_id: int | None = None`
     - `sport_id: int | None = None`
     - `kickoff_from: datetime | None = None` (filter events after this time)
     - `kickoff_to: datetime | None = None` (filter events before this time)
     - `min_bookmakers: int = Query(default=1, ge=1, le=3)` (minimum platforms with event)
     - `page: int = Query(default=1, ge=1)`
     - `page_size: int = Query(default=50, ge=1, le=100)`
   - Use SQLAlchemy `select(Event).options(selectinload(Event.bookmaker_links).selectinload(EventBookmaker.bookmaker))`
   - Join with Tournament for tournament_name
   - Apply filters dynamically
   - Use `offset((page - 1) * page_size).limit(page_size)`
   - Count total separately: `select(func.count()).select_from(Event)` with same filters
   - Return `MatchedEventList` with pagination info

3. `GET /events/{event_id}` - Single event detail:
   - Fetch Event by id with eager loading of bookmaker_links and tournament
   - Return `MatchedEvent` or 404

**Helper function `_build_matched_event(event: Event) -> MatchedEvent`:**
- Maps SQLAlchemy Event to Pydantic MatchedEvent
- Extracts bookmaker info from bookmaker_links relationship
- Includes tournament_name and sport_name from joined relations

**Import notes:**
- Use `selectinload` for eager loading relationships
- Use `func.count()` for efficient counting
  </action>
  <verify>python -c "from src.api.routes.events import router; print(f'Routes: {len(router.routes)}')"</verify>
  <done>GET /events/ and GET /events/{id} endpoints defined with filtering and pagination</done>
</task>

<task type="auto">
  <name>Task 2: Add unmatched events endpoint and wire router to app</name>
  <files>src/api/routes/events.py, src/api/main.py</files>
  <action>
Add unmatched events endpoint and register router with app.

**Add to events.py:**

4. `GET /events/unmatched` - List events with partial platform coverage:
   - Query params:
     - `missing_platform: str | None = None` (show events missing from specific platform)
     - `page: int = Query(default=1, ge=1)`
     - `page_size: int = Query(default=50, ge=1, le=100)`
   - Query: Events where count of bookmaker_links < 3 (not on all platforms)
   - Use subquery: `select(EventBookmaker.event_id).group_by(EventBookmaker.event_id).having(func.count() < 3)`
   - If missing_platform specified: find events NOT linked to that bookmaker
   - Return list of UnmatchedEvent with `missing_on` field showing which platforms lack the event

**IMPORTANT:** Define `/events/unmatched` route BEFORE `/events/{event_id}` to avoid path conflict.

**Modify src/api/main.py:**
- Import `from src.api.routes.events import router as events_router`
- Add `app.include_router(events_router)`
  </action>
  <verify>cd c:/Users/loren/Desktop/betpawa/comparison/mvp && python -c "from src.api.main import app; routes = [r.path for r in app.routes]; print('Events routes:', [r for r in routes if 'event' in r])"</verify>
  <done>GET /events/unmatched endpoint works, events router registered with app</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.api.routes.events import router"` succeeds
- [ ] Events router registered in main.py
- [ ] Route paths: /events/, /events/unmatched, /events/{event_id}
</verification>

<success_criteria>

- GET /events/ with filtering by tournament, sport, kickoff time, min_bookmakers
- GET /events/{id} returns single event detail
- GET /events/unmatched returns events with partial platform coverage
- All endpoints return proper Pydantic schemas
- Phase 4 complete - event matching service ready
</success_criteria>

<output>
After completion, create `.planning/phases/04-event-matching/04-02-SUMMARY.md`
</output>
