---
phase: 93.1-tournament-data-integrity
plan: 02
type: execute
---

<objective>
Create Alembic migration to clean up duplicate tournaments and add composite unique constraint.

Purpose: Fix existing corrupted data and prevent future data integrity violations.
Output: Alembic migration that deduplicates tournaments and adds UNIQUE(sport_id, name, country) constraint.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./93.1-02-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/ISSUES.md (BUG-016 details)

**Key files:**
@src/db/models/sport.py (Tournament model - needs constraint added)
@alembic/versions/ (migration files location)

**Prerequisite:** Plan 93.1-01 must be complete first (code fixes prevent new corruption).

**Data corruption scenario:**
- Multiple events with same tournament name but different countries linked to same tournament ID
- Example: "Premier League" tournament (ID=1, country="England") has events from England, Singapore, Malta, etc.

**Fix strategy:**
1. Identify tournaments that have events from multiple countries
2. For each multi-country tournament:
   - Keep the tournament for one country (the one matching Tournament.country or the most common)
   - Create new tournaments for other countries
   - Update Event.tournament_id foreign keys to point to correct tournaments
3. Ensure all tournaments have a country (set "Unknown" for any remaining nulls)
4. Add UNIQUE(sport_id, name, country) constraint

**Existing patterns:**
- Alembic async migrations used throughout project
- SQLAlchemy 2.0 style with execute() and text()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data cleanup and constraint migration</name>
  <files>alembic/versions/[timestamp]_fix_tournament_country_uniqueness.py</files>
  <action>
Create a new Alembic migration using: `cd src && alembic revision -m "fix_tournament_country_uniqueness"`

The migration upgrade() should:

**Step 1: Analyze and identify duplicates**
```python
# Find tournaments that have events with mismatched countries
# by comparing Tournament.country to the region in event data
# We need to infer correct country from the event's actual data

# First, get all tournaments with their event counts by unique regions
# This requires checking the raw data or inferring from existing patterns
```

**Step 2: Split tournaments by country**
```python
# For each tournament with events from multiple countries:
# 1. Query events linked to this tournament
# 2. Group events by their actual country (from kickoff region patterns or existing data)
# 3. Keep tournament for the country matching Tournament.country
# 4. Create new tournaments for other countries
# 5. Update Event.tournament_id to point to correct tournament

# SQL approach (more efficient for large datasets):
sql = '''
-- Step 1: Create temporary table mapping event_id to correct country
-- We'll need to determine country from event data or accept Tournament.country as canonical

-- Step 2: For tournaments where Tournament.country IS NULL, set it to the most common
-- country among its events, or "Unknown"

-- Step 3: Identify events that should be in a different tournament
-- (this is tricky - we may need to accept that past events are linked to a tournament
-- and just fix the lookup going forward)
'''
```

**Simplified approach (recommended):**
Since the code fix in Plan 01 prevents NEW corruption, the migration can be simpler:

1. **Set country for null tournaments:**
   ```python
   # Set country to "Unknown" for any tournaments with NULL country
   op.execute(text('''
       UPDATE tournaments
       SET country = 'Unknown'
       WHERE country IS NULL
   '''))
   ```

2. **Handle existing duplicates by appending country suffix:**
   ```python
   # If duplicates exist (same sport_id + name + country), make country unique
   # by appending a suffix based on tournament ID
   # This preserves data but makes constraint valid

   # Find duplicates first:
   # SELECT sport_id, name, country, COUNT(*)
   # FROM tournaments
   # GROUP BY sport_id, name, country
   # HAVING COUNT(*) > 1

   # For any duplicates, update country to include ID suffix
   # This is a fallback - ideally there are no true duplicates after code fix
   ```

3. **Add NOT NULL constraint on country:**
   ```python
   op.alter_column('tournaments', 'country',
       existing_type=sa.String(100),
       nullable=False,
       server_default='Unknown'
   )
   ```

4. **Add composite unique constraint:**
   ```python
   op.create_unique_constraint(
       'uq_tournaments_sport_name_country',
       'tournaments',
       ['sport_id', 'name', 'country']
   )
   ```

**downgrade() should:**
- Drop the unique constraint
- Make country nullable again
- (Don't try to undo data changes)

**Important:**
- Use `op.execute(text(...))` for raw SQL in Alembic
- Handle PostgreSQL-specific syntax if needed
- Test on a copy of production data if available
  </action>
  <verify>
Run migration validation: `cd src && alembic check`
Verify migration file exists and has proper upgrade/downgrade functions.
  </verify>
  <done>
- Migration file created in alembic/versions/
- upgrade() handles null countries, potential duplicates, adds constraint
- downgrade() properly reverses changes
- No syntax errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Tournament model with constraint annotation</name>
  <files>src/db/models/sport.py</files>
  <action>
Update the Tournament model to reflect the new constraint:

1. Add `__table_args__` with the unique constraint definition:
   ```python
   class Tournament(Base):
       """Tournament or league entity within a sport.

       ... existing docstring ...

       Constraints:
           - sportradar_id: unique (when not null)
           - (sport_id, name, country): unique composite key
       """

       __tablename__ = "tournaments"

       id: Mapped[int] = mapped_column(primary_key=True)
       sport_id: Mapped[int] = mapped_column(ForeignKey("sports.id"))
       name: Mapped[str] = mapped_column(String(255))
       country: Mapped[str] = mapped_column(String(100), nullable=False, default="Unknown")
       sportradar_id: Mapped[str | None] = mapped_column(
           String(100), unique=True, nullable=True
       )

       __table_args__ = (
           UniqueConstraint('sport_id', 'name', 'country', name='uq_tournaments_sport_name_country'),
       )

       # ... relationships ...
   ```

2. Import UniqueConstraint from sqlalchemy:
   ```python
   from sqlalchemy import ForeignKey, String, UniqueConstraint
   ```

3. Update the docstring to document:
   - country is now NOT NULL (default "Unknown")
   - Composite unique constraint on (sport_id, name, country)

**Note:** The model change is documentation/ORM-level only. The actual constraint is added by the migration.
  </action>
  <verify>
Run Python syntax check: `python -m py_compile src/db/models/sport.py`
Verify UniqueConstraint is properly imported and defined.
  </verify>
  <done>
- Tournament model has __table_args__ with UniqueConstraint
- country column updated to nullable=False with default
- Docstring updated to reflect constraints
- UniqueConstraint imported from sqlalchemy
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Migration file exists in alembic/versions/
- [ ] `cd src && alembic check` passes (or equivalent validation)
- [ ] `python -m py_compile src/db/models/sport.py` passes
- [ ] Tournament model has UniqueConstraint defined
- [ ] Migration handles null countries
- [ ] Migration adds composite unique constraint
- [ ] downgrade() properly reverses changes
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Migration ready to be applied (but NOT auto-applied - user should run manually)
- Tournament model updated to reflect new constraints
- BUG-016 fix complete - ready for closure after migration runs
</success_criteria>

<output>
After completion, create `.planning/phases/93.1-tournament-data-integrity/93.1-02-SUMMARY.md`

**Important note for user:** After plan completion, run the migration manually:
```bash
cd src && alembic upgrade head
```

This applies the constraint. Verify no errors before marking BUG-016 as resolved.
</output>
