---
phase: 70-backend-freshness-fixes
plan: 01
type: execute
---

<objective>
Fix backend timestamp handling so API returns `last_confirmed_at` (when odds were last verified) instead of `captured_at` (when odds last changed).

Purpose: Ensure users see accurate "freshness" timestamps that reflect when data was last scraped, not when it last changed. This is the root cause of the "4h ago" staleness issue identified in Phase 69.
Output: API returns fresh timestamps within 2 minutes of current time after each scrape, regardless of whether odds values changed.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/69-investigation-freshness-audit/69-01-SUMMARY.md
@.planning/phases/69-investigation-freshness-audit/FRESHNESS-AUDIT.md

# Key files to modify:
@src/caching/odds_cache.py
@src/caching/warmup.py
@src/api/routes/events.py

# Files that call cache helpers:
@src/scraping/event_coordinator.py (lines 1458, 1495, 1648, 1681)

**From Phase 69 Audit:**
- CRITICAL #1: Cache/DB timestamp inconsistency - cache stores fresh `captured_at`, DB stores time of last change
- CRITICAL #2: API uses `captured_at` instead of `last_confirmed_at`
- LOW #7: CachedSnapshot lacks `last_confirmed_at` field

**Fix strategy:** Add `last_confirmed_at` to CachedSnapshot and use it in API. The field already exists in DB and is updated every scrape.

**Established patterns:**
- Frozen dataclass cache entries (v2.0 Phase 54)
- Cache-first API pattern (v2.0 Phase 54)
- `snapshot_to_cached_from_models()` for in-memory ORM objects (v2.0 Phase 54)
- `snapshot_to_cached_from_data()` for DTO-to-cache conversion (v2.0 Phase 55)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add last_confirmed_at to CachedSnapshot</name>
  <files>src/caching/odds_cache.py</files>
  <action>
Add `last_confirmed_at: datetime` field to the CachedSnapshot frozen dataclass.

Place it after `captured_at` to maintain logical ordering. The field should have the same type as `captured_at` (datetime, not Optional) since callers will always provide a value.

```python
@dataclass(frozen=True)
class CachedSnapshot:
    snapshot_id: int
    event_id: int
    bookmaker_id: int
    captured_at: datetime
    last_confirmed_at: datetime  # <-- ADD THIS
    markets: tuple[CachedMarket, ...]
```

This field will be populated by the cache helpers and consumed by events.py for snapshot_time.
  </action>
  <verify>Python import check: `python -c "from src.caching.odds_cache import CachedSnapshot; print('ok')"`</verify>
  <done>CachedSnapshot has last_confirmed_at field, imports succeed</done>
</task>

<task type="auto">
  <name>Task 2: Update cache helpers and callers to pass last_confirmed_at</name>
  <files>src/caching/warmup.py, src/scraping/event_coordinator.py</files>
  <action>
**warmup.py - Update all 3 helper functions:**

1. `snapshot_to_cached_from_data()` (line 33):
   - Add `last_confirmed_at: datetime` parameter after `captured_at`
   - Pass it to CachedSnapshot constructor

2. `snapshot_to_cached_from_models()` (line 84):
   - Add `last_confirmed_at: datetime` parameter after `captured_at`
   - Pass it to CachedSnapshot constructor

3. `snapshot_to_cached()` (line 134):
   - Use `snapshot.last_confirmed_at` from ORM model
   - Handle None case by falling back to `snapshot.captured_at` (for old data before this field existed)

**event_coordinator.py - Update all 4 call sites:**

1. Line ~1458 (async path, BetPawa):
   ```python
   cached = snapshot_to_cached_from_data(
       snapshot_id=snap_id,
       event_id=swd.event_id,
       bookmaker_id=swd.bookmaker_id,
       captured_at=now_naive,
       last_confirmed_at=now_naive,  # <-- ADD (fresh scrape time)
       markets=swd.markets,
   )
   ```

2. Line ~1495 (async path, competitor):
   ```python
   cached = snapshot_to_cached_from_data(
       snapshot_id=snap_id,
       event_id=betpawa_eid,
       bookmaker_id=0,
       captured_at=now_naive,
       last_confirmed_at=now_naive,  # <-- ADD
       markets=cswd.markets,
   )
   ```

3. Line ~1648 (sync fallback, BetPawa):
   ```python
   last_confirmed = snapshot.last_confirmed_at or captured_at
   cached = snapshot_to_cached_from_models(
       snapshot_id=snapshot.id,
       event_id=snapshot.event_id,
       bookmaker_id=snapshot.bookmaker_id,
       captured_at=captured_at,
       last_confirmed_at=last_confirmed,  # <-- ADD
       markets=markets,
   )
   ```

4. Line ~1681 (sync fallback, competitor):
   ```python
   last_confirmed = snapshot.last_confirmed_at or captured_at
   cached = snapshot_to_cached_from_models(
       snapshot_id=snapshot.id,
       event_id=betpawa_event_id,
       bookmaker_id=0,
       captured_at=captured_at,
       last_confirmed_at=last_confirmed,  # <-- ADD
       markets=markets,
   )
   ```

The async path uses `now_naive` for both timestamps (data was just scraped, so confirmed = now).
The sync fallback reads from ORM model with None fallback (handles migration period).
  </action>
  <verify>
- `python -c "from src.caching.warmup import snapshot_to_cached_from_data, snapshot_to_cached_from_models, snapshot_to_cached; print('ok')"`
- `python -c "from src.scraping.event_coordinator import EventCoordinator; print('ok')"`
  </verify>
  <done>All 3 helpers accept last_confirmed_at, all 4 callers pass it, imports succeed</done>
</task>

<task type="auto">
  <name>Task 3: Update events.py API to use last_confirmed_at for snapshot_time</name>
  <files>src/api/routes/events.py</files>
  <action>
Change all 7 locations where `snapshot_time = snapshot.captured_at` to use `last_confirmed_at` instead.

Use a helper pattern to handle None gracefully (for cache entries created before this field existed):

```python
# At each location, change:
snapshot_time = snapshot.captured_at if snapshot else None

# To:
snapshot_time = (
    getattr(snapshot, 'last_confirmed_at', None) or snapshot.captured_at
    if snapshot else None
)
```

Or define a small helper at module level if cleaner:

```python
def _get_snapshot_time(snapshot) -> datetime | None:
    """Get freshness timestamp preferring last_confirmed_at over captured_at."""
    if not snapshot:
        return None
    return getattr(snapshot, 'last_confirmed_at', None) or snapshot.captured_at
```

Then replace all 7 occurrences:
- Line 194: competitor snapshot in _build_bookmaker_inline_odds
- Line 200: BetPawa snapshot in _build_bookmaker_inline_odds
- Line 488: single event snapshot in get_events
- Line 598: BetPawa snapshot in get_event_detail
- Line 665: competitor snapshot in get_event_detail
- Line 718: competitor snapshot in _get_comparison_bookmakers
- Line 743: BetPawa snapshot in _get_comparison_bookmakers

**WHY this works:**
- `last_confirmed_at` is updated every scrape (even for unchanged odds)
- It represents "when was this data last verified" - what users want to see
- Falls back to `captured_at` for old data or during migration
- CachedSnapshot now has both fields, DB models already have both fields
  </action>
  <verify>
- `python -c "from src.api.routes.events import router; print('ok')"`
- Start server and verify API returns fresh timestamps: `curl http://localhost:8000/api/events?limit=1 | jq '.items[0].bookmakers[0].snapshot_time'`
  </verify>
  <done>All 7 locations use last_confirmed_at, API returns fresh timestamps after scrape</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "from src.caching.odds_cache import CachedSnapshot; print(CachedSnapshot.__dataclass_fields__.keys())"` shows `last_confirmed_at`
- [ ] `python -c "from src.caching.warmup import snapshot_to_cached_from_data; import inspect; print('last_confirmed_at' in inspect.signature(snapshot_to_cached_from_data).parameters)"` returns True
- [ ] Server starts without errors
- [ ] After a scrape cycle, API returns `snapshot_time` within 2 minutes of current time
- [ ] No TypeScript/type errors (frontend unchanged, uses same field name)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- CachedSnapshot has last_confirmed_at field
- All 3 cache helpers accept and pass last_confirmed_at
- All 4 event_coordinator call sites pass last_confirmed_at
- All 7 events.py locations use last_confirmed_at for snapshot_time
- API returns fresh timestamps regardless of whether odds values changed
</success_criteria>

<output>
After completion, create `.planning/phases/70-backend-freshness-fixes/70-01-SUMMARY.md`:

# Phase 70 Plan 01: Backend Freshness Fixes Summary

**[One-liner: what shipped]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `src/caching/odds_cache.py` - Added last_confirmed_at to CachedSnapshot
- `src/caching/warmup.py` - Updated 3 cache helpers
- `src/scraping/event_coordinator.py` - Updated 4 call sites
- `src/api/routes/events.py` - Changed 7 snapshot_time assignments

## Decisions Made

[Any decisions or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 71 (Frontend Freshness Fixes) ready:
- Backend now returns correct timestamps
- Frontend needs to subscribe to odds_updates WebSocket topic
- Frontend needs query invalidation on odds_update messages
</output>
