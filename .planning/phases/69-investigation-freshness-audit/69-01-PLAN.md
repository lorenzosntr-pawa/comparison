---
phase: 69-investigation-freshness-audit
plan: 01
type: execute
---

<objective>
Trace the complete data flow from scraping to display, documenting all timestamp touch points and identifying potential staleness sources.

Purpose: Understand exactly where and why odds data might appear stale to users, enabling targeted fixes in Phases 70-71.
Output: FRESHNESS-AUDIT.md documenting data flow, timestamp lifecycle, and identified staleness issues.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (v2.0 real-time pipeline):
@.planning/phases/55-async-write-pipeline/55-03-SUMMARY.md
@.planning/phases/57-websocket-infrastructure/57-03-SUMMARY.md
@.planning/phases/59-sse-removal-cleanup/59-02-SUMMARY.md

# Prior phase summary (v2.1 timestamps):
@.planning/phases/63-freshness-timestamps/63-01-SUMMARY.md

# Key source files - Backend data flow:
@src/scraping/event_coordinator.py
@src/caching/odds_cache.py
@src/caching/change_detection.py
@src/storage/write_queue.py
@src/storage/write_handler.py
@src/api/routes/events.py

# Key source files - WebSocket broadcasting:
@src/api/websocket/manager.py
@src/api/websocket/bridge.py
@src/api/websocket/messages.py

# Key source files - Frontend reactivity:
@web/src/features/dashboard/hooks/use-active-scrapes-observer.ts
@web/src/features/scrape-runs/hooks/use-scrape-progress.ts
@web/src/features/matches/lib/market-utils.ts

**Tech stack available:**
- OddsCache with on_update callbacks (v2.0 Phase 54/57)
- AsyncWriteQueue with change detection (v2.0 Phase 55)
- WebSocket ConnectionManager with topic pub/sub (v2.0 Phase 57)
- WebSocket-only frontend (v2.0 Phase 59)
- snapshot_time field with formatRelativeTime (v2.1 Phase 63)

**Established patterns:**
- Cache-before-persist: OddsCache updated immediately, DB write async
- OddsCache on_update callback fires on cache mutations, schedules WebSocket broadcast
- WebSocket message envelope: {type, timestamp, data}
- Frontend TanStack Query with polling intervals

**Key questions to answer:**
1. When is `captured_at` set? Is it scrape time or storage time?
2. Does `last_confirmed_at` update when odds are unchanged?
3. Does WebSocket broadcast on every cache put or only on change?
4. Does frontend invalidate TanStack Query cache on WebSocket message?
5. What happens to freshness timestamps when multiple scrape cycles don't detect changes?
</context>

<tasks>

<task type="auto">
  <name>Task 1: Trace backend data flow and timestamp lifecycle</name>
  <files>
    src/scraping/event_coordinator.py,
    src/caching/odds_cache.py,
    src/storage/write_handler.py,
    src/api/routes/events.py
  </files>
  <action>
Read and trace the complete backend data path for odds data:

1. **Scraping phase** (event_coordinator.py):
   - Find where `captured_at` is set on new snapshots
   - Find where `last_confirmed_at` is set/updated
   - Trace the change detection flow: when are snapshots classified as "changed" vs "unchanged"?
   - Document what happens to unchanged data (does it update any timestamps?)

2. **Cache phase** (odds_cache.py):
   - Find `put_betpawa_snapshot` and `put_competitor_snapshot` methods
   - Check if on_update callbacks fire for ALL puts or only for changed data
   - Document whether the cache stores `captured_at` or derives it

3. **Storage phase** (write_handler.py):
   - Check what timestamps are written for INSERT (new/changed snapshots)
   - Check what timestamps are written for UPDATE (unchanged snapshots via last_confirmed_at)
   - Verify the timezone handling (naive UTC pattern)

4. **API phase** (events.py):
   - Find how `snapshot_time` is populated in BookmakerOdds
   - Check if it uses `captured_at` or `last_confirmed_at` or something else
   - Document the cache-first vs DB-fallback paths and their timestamp differences

Create initial findings in `.planning/phases/69-investigation-freshness-audit/FRESHNESS-AUDIT.md` with:
- Data flow diagram (ASCII)
- Timestamp lifecycle table
- Initial observations and potential issues
  </action>
  <verify>
FRESHNESS-AUDIT.md exists with:
- Data flow section documenting scrape → cache → storage → API path
- Timestamp lifecycle section with captured_at and last_confirmed_at behavior
- Initial observations section with at least 2 potential staleness sources identified
  </verify>
  <done>Backend data flow fully traced, timestamps documented, initial staleness sources identified</done>
</task>

<task type="auto">
  <name>Task 2: Trace WebSocket and frontend reactivity path</name>
  <files>
    src/api/websocket/bridge.py,
    src/api/websocket/messages.py,
    web/src/features/dashboard/hooks/use-active-scrapes-observer.ts,
    web/src/features/matches/lib/market-utils.ts,
    web/src/features/matches/components/match-table.tsx
  </files>
  <action>
Read and trace the real-time update path from cache to UI:

1. **WebSocket broadcast** (bridge.py, messages.py):
   - Find what triggers `odds_update` broadcasts
   - Check the message payload: does it include timestamps?
   - Check if broadcast happens on EVERY cache update or only on change

2. **Frontend WebSocket handling** (use-active-scrapes-observer.ts):
   - Find how WebSocket messages are received
   - Check what happens when an odds_update message arrives
   - Does it invalidate TanStack Query cache?
   - Does it trigger a re-fetch?

3. **Frontend timestamp display** (market-utils.ts, match-table.tsx):
   - Trace how snapshot_time flows from API response to UI
   - Check formatRelativeTime implementation
   - Find where timestamps are rendered in the UI

4. **TanStack Query polling** (match-table.tsx or hooks):
   - Find the refetchInterval/staleTime configuration
   - Check if WebSocket updates trigger immediate refetch or wait for next poll

Document findings in FRESHNESS-AUDIT.md:
- WebSocket message flow diagram
- Frontend reactivity chain
- TanStack Query configuration analysis
- Identified gaps in real-time updates
  </action>
  <verify>
FRESHNESS-AUDIT.md updated with:
- WebSocket section documenting broadcast triggers and message content
- Frontend section documenting TanStack Query behavior
- At least 2 additional potential staleness sources identified from frontend analysis
  </verify>
  <done>WebSocket and frontend paths fully traced, reactivity gaps identified</done>
</task>

<task type="auto">
  <name>Task 3: Compile staleness audit report with prioritized findings</name>
  <files>
    .planning/phases/69-investigation-freshness-audit/FRESHNESS-AUDIT.md
  </files>
  <action>
Consolidate all findings into a comprehensive audit report:

1. **Executive summary**: One paragraph describing the freshness architecture and overall assessment

2. **Data flow diagram**: Complete ASCII diagram showing:
   - Scrape → Cache → WriteQueue → DB
   - API read path (cache-first)
   - WebSocket broadcast path
   - Frontend reactivity path

3. **Timestamp inventory**: Table of all timestamps in the system:
   | Field | Set when | Updated when | Used for |
   | captured_at | ? | ? | ? |
   | last_confirmed_at | ? | ? | ? |
   | snapshot_time | ? | ? | ? |

4. **Staleness sources**: Prioritized list of identified issues:
   - CRITICAL: Issues causing obviously stale data
   - HIGH: Issues causing subtle staleness
   - MEDIUM: Potential edge cases
   - LOW: Theoretical concerns

5. **Recommended fixes**: Map each staleness source to Phase 70 (backend) or Phase 71 (frontend)

6. **Verification checklist**: How to verify freshness is working:
   - Manual test steps
   - Log events to monitor
   - Expected behavior
  </action>
  <verify>
FRESHNESS-AUDIT.md is complete with:
- Executive summary
- Complete data flow diagram
- Timestamp inventory table
- At least 4 staleness sources categorized by severity
- Fix recommendations mapped to Phase 70/71
- Verification checklist with at least 5 items
  </verify>
  <done>Comprehensive freshness audit complete, ready to guide Phase 70-71 implementation</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] FRESHNESS-AUDIT.md exists in phase directory
- [ ] All timestamp fields documented with lifecycle
- [ ] Complete data flow from scrape to display traced
- [ ] Staleness sources prioritized by severity
- [ ] Fix recommendations mapped to Phase 70 (backend) or Phase 71 (frontend)
- [ ] No code changes made (investigation only)
</verification>

<success_criteria>

- All tasks completed
- FRESHNESS-AUDIT.md provides clear guidance for Phase 70-71
- Staleness sources identified and prioritized
- No code changes (pure investigation)
  </success_criteria>

<output>
After completion, create `.planning/phases/69-investigation-freshness-audit/69-01-SUMMARY.md`:

# Phase 69 Plan 01: Investigation & Freshness Audit Summary

**[One-liner describing key findings]**

## Accomplishments

- Traced complete data flow from scraping to display
- Documented all timestamp fields and their lifecycle
- Identified [N] staleness sources across backend and frontend
- Created prioritized fix recommendations for Phase 70-71

## Files Created

- `.planning/phases/69-investigation-freshness-audit/FRESHNESS-AUDIT.md` - Complete audit document

## Key Findings

[Summary of most important staleness sources]

## Next Phase Readiness

Phase 70 (Backend Freshness Fixes) should address:
- [List backend issues from audit]

Phase 71 (Frontend Freshness Fixes) should address:
- [List frontend issues from audit]
</output>
