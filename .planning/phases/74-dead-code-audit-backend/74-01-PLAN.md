---
phase: 74-dead-code-audit-backend
plan: 01
type: execute
---

<objective>
Scan Python backend codebase for unused code and remove it.

Purpose: Clean up technical debt from iterative development (SSEâ†’WebSocket migration, architecture changes) to improve maintainability.
Output: Cleaner codebase with dead code removed, verified by tests passing.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/CONCERNS.md

**Key context from prior phases:**
- Phase 59 (v2.0): SSE endpoints and frontend code removed, WebSocket-only architecture
- Phase 55.1: Various bug fixes that may have left commented code
- 88 Python files in src/ directory

**Potential dead code sources:**
1. SSE-related code remnants after WebSocket migration (Phase 57-59)
2. Unused imports accumulated over 156+ plans
3. Deprecated helper functions from refactored services
4. Scripts in src/scripts/ that may no longer be needed
5. Unused type definitions or schemas

**Tech stack:**
- Python 3.11+, FastAPI, SQLAlchemy 2.0, Pydantic v2
- structlog for logging
- No test suite exists (manual verification only)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run static analysis to identify dead code</name>
  <files>src/**/*.py (read-only scan)</files>
  <action>
Use multiple approaches to identify dead code:

1. **Scan for unused imports** using grep/ast analysis:
   - Find imports at top of files
   - Check if imported names are used in the file
   - List candidates for removal

2. **Identify unused functions/classes** by tracing call graphs:
   - Scan all function/class definitions
   - Search for usage across the codebase
   - Focus on likely dead code areas:
     - src/scripts/ (one-off analysis scripts)
     - Any SSE-related code that may remain
     - Helper functions that may be unused after refactors

3. **Check for deprecated patterns:**
   - Search for "TODO", "FIXME", "DEPRECATED" comments
   - Search for SSE-related code (`EventSource`, `stream`, SSE endpoint patterns)
   - Search for commented-out code blocks

**Output:** Create a list of dead code candidates categorized by:
- HIGH CONFIDENCE: Clearly unused (no callers found)
- MEDIUM CONFIDENCE: Potentially unused (only internal use, may be entry point)
- LOW CONFIDENCE: Needs verification (might be used dynamically)

Do NOT delete anything in this task - only analyze and document findings.
  </action>
  <verify>Analysis complete with categorized findings documented</verify>
  <done>Dead code candidates identified and categorized by confidence level</done>
</task>

<task type="auto">
  <name>Task 2: Remove confirmed dead code</name>
  <files>Files identified in Task 1</files>
  <action>
Based on Task 1 findings, remove confirmed dead code:

1. **Remove unused imports** (HIGH CONFIDENCE only):
   - Delete import lines that are clearly unused
   - Preserve __all__ exports and type-checking imports

2. **Remove unused functions/classes** (HIGH CONFIDENCE only):
   - Delete function/class definitions with no callers
   - For src/scripts/*.py: Delete entire files if they were one-off audit scripts (analyze_outcomes.py, audit_market_mapping.py, verify_market_fixes.py were used for v1.8 market mapping audit and are no longer needed)

3. **Clean up deprecated patterns:**
   - Remove TODO/FIXME comments that are no longer relevant
   - Remove any remaining SSE-related code
   - Remove commented-out code blocks

**Preserve:**
- Entry points (FastAPI routes, scheduled jobs, CLI commands)
- __init__.py exports (may be used externally)
- Type definitions (used for documentation/type checking)
- Logging statements

**Do NOT remove MEDIUM or LOW confidence items** - document them for future review.
  </action>
  <verify>
Run the application and verify it starts without import errors:
```bash
cd src && python -c "from api.app import app; print('App imports OK')"
```
  </verify>
  <done>
- Dead code removed
- Application starts without errors
- No import errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Document remaining concerns</name>
  <files>.planning/codebase/CONCERNS.md</files>
  <action>
Update CONCERNS.md with findings from this audit:

1. Add any MEDIUM/LOW confidence dead code items that weren't removed (for future review)
2. Update analysis date
3. Remove any concerns that were addressed by this cleanup

Format for documenting deferred items:
```markdown
**Potentially unused code (Phase 74 audit):**
- File: path/to/file.py
- Item: function_name or ClassName
- Confidence: MEDIUM/LOW
- Reason deferred: [why not removed]
```
  </action>
  <verify>CONCERNS.md updated with current information</verify>
  <done>Remaining concerns documented for future review</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Static analysis completed and documented
- [ ] HIGH CONFIDENCE dead code removed
- [ ] Application imports without errors (`python -c "from api.app import app"`)
- [ ] CONCERNS.md updated with remaining items
- [ ] No regression in functionality (manual smoke test)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Backend codebase is cleaner with documented rationale for changes
- Any uncertain items documented in CONCERNS.md for future review
</success_criteria>

<output>
After completion, create `.planning/phases/74-dead-code-audit-backend/74-01-SUMMARY.md`:

# Phase 74 Plan 01: Backend Dead Code Audit Summary

**[One-liner summarizing what was cleaned up]**

## Accomplishments
- [Dead code items removed]
- [LOC reduction if significant]

## Files Created/Modified
- [List of files changed]

## Dead Code Removed
- [Category: imports/functions/scripts]
- [Specific items removed]

## Deferred for Review
- [MEDIUM/LOW confidence items not removed]

## Issues Encountered
[Problems and resolutions, or "None"]

## Next Phase Readiness
- Ready for Phase 75: Dead Code Audit & Removal (Frontend)
</output>
