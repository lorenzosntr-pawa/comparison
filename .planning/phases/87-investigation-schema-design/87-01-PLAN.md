---
phase: 87-investigation-schema-design
plan: 01
type: execute
---

<objective>
Investigate current data flow and design availability tracking for v2.5 milestone.

Purpose: Understand how unavailability manifests in current system and design schema/API changes to track when events, markets, and outcomes become unavailable.
Output: DISCOVERY.md with complete analysis and design specification for Phases 88-92.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-investigation-schema-design/60-01-SUMMARY.md

# Key files for understanding current data flow:
@src/db/models/odds.py
@src/caching/odds_cache.py
@src/scraping/event_coordinator.py
@web/src/features/matches/components/odds-badge.tsx

**Background:**
The v2.5 milestone introduces availability tracking to show when odds/events become unavailable. Current system behavior:
- When a bookmaker stops offering an event, scraping simply returns no data
- When a market disappears, it's absent from the next snapshot
- When an outcome is suspended, `is_active=false` is set in outcomes JSON
- There's no explicit tracking of WHEN something became unavailable

**What "unavailable" means:**
1. **Event unavailable**: Bookmaker no longer offers odds for this match (removed from API)
2. **Market unavailable**: Specific market (e.g., Over 2.5) no longer offered for an event
3. **Outcome suspended**: Selection exists but is_active=false (already handled)

**Key challenge:** Detecting absences - knowing something WAS there and is now GONE.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Analyze current data patterns for unavailability</name>
  <files>DISCOVERY.md (analysis section)</files>
  <action>
Run diagnostic SQL queries to understand:

1. **Event-level gaps**: How often do events appear in some snapshots but not others?
   - Find events with snapshots from one bookmaker but not another
   - Find events that had snapshots then stopped appearing
   - Quantify "gap" patterns in data

2. **Market-level gaps**: How stable are market offerings over time?
   - Find markets that appear in early snapshots but disappear
   - Calculate market presence rate per bookmaker over event lifetime
   - Identify patterns (do markets drop closer to kickoff?)

3. **Outcome suspension patterns**: How often is is_active=false?
   - Count suspended outcomes across snapshots
   - Pattern: Are suspensions temporary or permanent?

4. **Cache implications**: How would availability affect cache?
   - Current cache only stores latest snapshot
   - Need to track "last known state" vs "current state"

Document findings with SQL queries and results in DISCOVERY.md.
  </action>
  <verify>DISCOVERY.md contains "Data Analysis" section with SQL queries and quantified findings</verify>
  <done>Gap patterns documented, frequency of unavailability events quantified, cache implications identified</done>
</task>

<task type="auto">
  <name>Task 2: Design availability tracking schema and API</name>
  <files>DISCOVERY.md (design section)</files>
  <action>
Based on analysis, design the availability tracking approach:

**Schema Design:**
1. Evaluate options for tracking availability state:
   - Option A: Add `available` boolean to OddsSnapshot/MarketOdds
   - Option B: Add `unavailable_at` timestamp to track when it became unavailable
   - Option C: Separate availability_transitions table for history
   - Option D: Use absence detection at API/cache layer (no schema change)

2. For each option, assess:
   - Storage impact (how much additional data?)
   - Query complexity (how hard to query historical availability?)
   - Implementation complexity (changes needed in scraper, cache, API)
   - History chart impact (can we show availability transitions?)

**API Design:**
1. What fields need to be added to API responses?
   - `available: boolean` per market/outcome?
   - `unavailable_since: timestamp` for strikethrough tooltip?
   - `availability_state: 'available' | 'unavailable' | 'never_offered'`?

2. How does this affect existing endpoints?
   - GET /api/events - inline odds structure
   - GET /api/events/:id - event detail
   - GET /api/history/* - historical data

**Cache Design:**
1. How to track availability in CachedSnapshot/CachedMarket?
   - Add `available` field to frozen dataclass?
   - Separate availability tracking dict in OddsCache?

2. How to detect unavailability?
   - Compare new scrape results to previous cache state
   - If market was in cache but not in new data â†’ unavailable
   - Need to distinguish "not scraped yet" from "became unavailable"

**Detection Logic:**
1. When scrape completes for an event+bookmaker:
   - Compare returned markets to previously cached markets
   - For each missing market: mark as unavailable with timestamp
   - For each new market: mark as available
   - For each existing market: update odds, keep available

2. Edge cases:
   - First scrape for an event (no previous state)
   - Scrape failure vs event unavailability
   - Market temporarily suspended vs removed

Write complete design specification in DISCOVERY.md with recommended approach.
  </action>
  <verify>DISCOVERY.md contains "Design Specification" section with recommended schema, API, cache changes, and detection logic</verify>
  <done>Complete design documented with recommended option, schema changes, API changes, cache changes, and implementation outline for Phases 88-92</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] SQL analysis queries executed against actual database
- [ ] Findings quantified (not just "sometimes happens")
- [ ] Multiple design options evaluated with trade-offs
- [ ] Single recommended approach selected with rationale
- [ ] DISCOVERY.md provides complete specification for Phase 88 implementation
</verification>

<success_criteria>
- DISCOVERY.md created with complete analysis and design
- Current unavailability patterns in data documented with numbers
- Schema design decision made with clear rationale
- API response changes specified
- Cache layer changes specified
- Detection logic documented for implementation
- Phase 88 can proceed without additional investigation
</success_criteria>

<output>
After completion, create `.planning/phases/87-investigation-schema-design/87-01-SUMMARY.md`:

# Phase 87 Plan 01: Investigation & Schema Design Summary

**[One-liner: key finding/decision]**

## Accomplishments

- [Data analysis findings]
- [Design decision made]

## Files Created/Modified

- `.planning/phases/87-investigation-schema-design/DISCOVERY.md` - Full analysis and design spec

## Decisions Made

1. [Primary design choice with rationale]
2. [Key trade-offs considered]

## Issues Encountered

[Any surprises in the analysis]

## Next Phase Readiness

- Phase 88 can implement [X] based on DISCOVERY.md specification
- [Any blockers or dependencies]
</output>
