---
phase: 103-mapping-dashboard
plan: 01
type: execute
---

<objective>
Create backend API endpoints for the Mapping Dashboard stats and audit log.

Purpose: Provide aggregated statistics and recent changes data for the frontend dashboard.
Output: Two new API endpoints: /mappings/stats and /audit-log
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context:
@.planning/phases/101-backend-foundation/101-03-SUMMARY.md
@.planning/phases/102-unmapped-discovery/102-02-SUMMARY.md

# Key files:
@src/api/routes/mappings.py
@src/api/routes/unmapped.py
@src/market_mapping/cache.py
@src/db/models/mapping.py

**Tech stack available:** FastAPI, Pydantic, SQLAlchemy async, MappingCache singleton
**Established patterns:** Cache-first API reads, Pydantic schemas with camelCase aliases
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create /mappings/stats endpoint</name>
  <files>src/api/schemas/mappings.py, src/api/routes/mappings.py</files>
  <action>
Add MappingStatsResponse Pydantic schema with fields:
- total_mappings: int (total from cache)
- code_mappings: int (from code)
- db_mappings: int (from user overrides)
- by_platform: dict with betpawa_count, sportybet_count, bet9ja_count
- unmapped_counts: dict with new, acknowledged, mapped, ignored counts
- cache_loaded_at: datetime | None

Add GET /mappings/stats endpoint that:
1. Gets stats from mapping_cache.stats() (total, code, db, by_betpawa, by_sportybet, by_bet9ja)
2. Queries unmapped_market_log to count by status (NEW, ACKNOWLEDGED, MAPPED, IGNORED)
3. Returns MappingStatsResponse

Use existing pattern from mappings.py - no checkpoint needed, pure backend work.
  </action>
  <verify>
curl http://localhost:8000/api/mappings/stats returns JSON with all stats fields
  </verify>
  <done>
Stats endpoint returns total_mappings, code_mappings, db_mappings, by_platform counts, and unmapped_counts by status
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /audit-log endpoint</name>
  <files>src/api/schemas/mappings.py, src/api/routes/mappings.py</files>
  <action>
Add Pydantic schemas:
- AuditLogItem: id, canonical_id, action, reason, created_at, created_by (camelCase aliases)
- AuditLogResponse: items list, total count, page, page_size

Add GET /mappings/audit-log endpoint with:
- Query params: page (1-indexed), page_size (default 20, max 100), action filter (optional)
- Query MappingAuditLog table, order by created_at DESC
- Paginate results and return AuditLogResponse

Follow existing pagination pattern from list_unmapped_markets in unmapped.py.
  </action>
  <verify>
curl http://localhost:8000/api/mappings/audit-log returns paginated list of audit entries
  </verify>
  <done>
Audit log endpoint returns paginated entries with canonical_id, action, reason, created_at fields
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] GET /mappings/stats returns correct counts from cache and DB
- [ ] GET /mappings/audit-log returns paginated audit entries
- [ ] Both endpoints handle empty data gracefully
- [ ] No TypeScript/Python errors
</verification>

<success_criteria>

- Both endpoints functional and returning correct data
- Pydantic schemas with proper camelCase aliasing for frontend
- Follows existing API patterns (pagination, filtering)
- All verification checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/103-mapping-dashboard/103-01-SUMMARY.md`
</output>
