---
phase: 93-odds-comparison-page
plan: 01-FIX2
type: fix
---

<objective>
Fix 3 UAT issues from plan 93-01 re-test (after 93-01-FIX).

Source: 93-01-ISSUES.md
Priority: 1 blocker, 1 major, 1 minor (enhancement)

- UAT-004 (Blocker): API 500 error when filtering in competitor-only mode
- UAT-003 (Major): Country filter doesn't scope to availability mode
- UAT-005 (Minor): Filter state not preserved per availability mode
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/93-odds-comparison-page/93-01-ISSUES.md

**Original plan for reference:**
@.planning/phases/93-odds-comparison-page/93-01-PLAN.md

**Key files:**
@src/api/routes/events.py
@web/src/features/matches/components/match-filters.tsx
@web/src/features/matches/index.tsx

**Problem analysis:**

1. **UAT-004 (Blocker):** API returns 500 "No matches found" instead of empty list. The backend throws an exception when tournament name matching returns no results, instead of returning an empty list gracefully.

2. **UAT-003 (Major):** The country filter extracts countries from useTournaments, which correctly scopes to availability mode. But the list of countries is derived from tournaments data AFTER the tournaments API returns. The issue is that when tournament_names is empty in competitor mode (no matching tournaments), the frontend still shows all countries from the useTournaments data. Need to add a dedicated API endpoint for countries that also scopes to availability mode, OR ensure the tournament scoping handles the case properly.

   Looking at the code: `const countries = Array.from(new Set(tournaments?.map((t) => t.country)...)`. This correctly derives countries from tournaments, which are scoped by availability. So if useTournaments returns only competitor-matching tournaments, the countries SHOULD be scoped correctly. Let me trace the issue further...

   Actually, reviewing the code again: the `/events/tournaments` endpoint with `availability=competitor` returns BetPawa tournaments that MATCH competitor tournament names. So countries extracted from those tournaments ARE the competitor-relevant countries. The issue may be that the tournament-to-country mapping is working, but the API itself returns an error before the frontend can derive countries.

   The real root cause: The 500 error in UAT-004 happens BEFORE the frontend can properly derive countries. When the API fails, the tournaments call might also be failing or returning unexpected data. Need to fix the 500 error first, then verify country scoping.

3. **UAT-005 (Minor):** User wants separate filter state per availability mode. When switching modes, filters should be preserved independently for each mode.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix API 500 error - return empty list instead of 500</name>
  <files>src/api/routes/events.py</files>
  <action>
Fix the competitor events endpoint to return empty list gracefully when no matches found.

Investigation: The 500 error "No matches found" likely comes from:
1. The tournament name matching returning empty list
2. Some subsequent operation failing on empty data

In `list_events()` around lines 1224-1247:
- When `tournament_ids` provided but no matching tournament names found, `tournament_names` is empty
- When `tournament_names` is empty, the query should just return no results (not error)

The fix should:
1. Check if `tournament_names` is empty after querying Tournament table
2. If empty with tournament_ids provided in competitor mode, return empty list immediately (no matching tournaments)
3. Ensure no exceptions are raised for empty results anywhere in the competitor path

Also check the entire competitor events path (lines 1145-1298) for any code that might throw on empty data:
- `comp_events` could be empty - should work fine
- `sr_id_events` dict operations should handle empty
- `deduped_events` empty list should work
- Pagination on empty list should work

The 500 error message "No matches found" suggests a custom exception is being raised somewhere. Search for this message and remove or convert to empty response.
  </action>
  <verify>
1. Start backend and test:
   - `curl "http://localhost:8000/api/events?availability=competitor"` - should return events or empty list (200)
   - `curl "http://localhost:8000/api/events?availability=competitor&tournament_ids=99999"` - should return empty list (200), not 500
   - `curl "http://localhost:8000/api/events?availability=competitor&countries=NonexistentCountry"` - should return empty list (200)
2. No 500 errors for any valid filter combination
  </verify>
  <done>
API returns 200 with empty events list when no matches found, not 500 error
  </done>
</task>

<task type="auto">
  <name>Task 2: Add countries endpoint with availability scoping</name>
  <files>src/api/routes/events.py, web/src/lib/api.ts, web/src/features/matches/hooks/use-tournaments.ts</files>
  <action>
Add a dedicated `/events/countries` endpoint that supports availability scoping, similar to `/events/tournaments`.

Backend (events.py):
1. Add new endpoint `GET /events/countries`:
   ```python
   @router.get("/countries", response_model=list[str])
   async def list_countries(
       db: AsyncSession = Depends(get_db),
       availability: Literal["betpawa", "competitor"] | None = Query(
           default=None,
           description="Filter countries by availability mode"
       ),
   ) -> list[str]:
   ```

2. Implementation:
   - If `availability=None` or `availability="betpawa"`: Return distinct countries from Tournament table (joined with Event where kickoff > now)
   - If `availability="competitor"`: Return distinct countries from CompetitorTournament table (joined with CompetitorEvent where betpawa_event_id IS NULL and kickoff > now)

3. Return sorted list of country strings (not null)

Frontend:
1. Add `getCountries(availability?)` to api.ts
2. Create `useCountries` hook in hooks/ directory (similar to useTournaments)
3. Update match-filters.tsx to use `useCountries({ availability: filters.availability })` instead of deriving from tournaments

This ensures the country dropdown is properly scoped to the availability mode, independent of the tournament list.
  </action>
  <verify>
1. Test API:
   - `curl "http://localhost:8000/api/events/countries"` - returns all countries
   - `curl "http://localhost:8000/api/events/countries?availability=competitor"` - returns only countries with competitor-only events
2. Test UI:
   - In competitor-only mode, country dropdown shows only countries with competitor events
   - Countries list is different between modes (competitor should be smaller subset)
  </verify>
  <done>
Country filter shows only countries relevant to current availability mode
  </done>
</task>

<task type="auto">
  <name>Task 3: Preserve filter state per availability mode</name>
  <files>web/src/features/matches/index.tsx, web/src/features/matches/components/match-filters.tsx</files>
  <action>
Implement separate filter state for each availability mode.

In index.tsx:
1. Change from single `filters` state to per-mode state:
   ```typescript
   const [betpawaFilters, setBetpawaFilters] = useState<MatchFiltersState>(DEFAULT_FILTERS)
   const [competitorFilters, setCompetitorFilters] = useState<MatchFiltersState>({
     ...DEFAULT_FILTERS,
     availability: 'competitor'
   })
   ```

2. Add `currentMode` state to track which mode is active:
   ```typescript
   const [currentMode, setCurrentMode] = useState<'betpawa' | 'competitor'>('betpawa')
   ```

3. Create computed `currentFilters` and `setCurrentFilters` based on mode:
   ```typescript
   const currentFilters = currentMode === 'betpawa' ? betpawaFilters : competitorFilters
   const setCurrentFilters = currentMode === 'betpawa' ? setBetpawaFilters : setCompetitorFilters
   ```

4. Handle mode switching separately from filter changes:
   - When user changes availability in filters, update `currentMode`
   - Don't reset filters on mode switch - use the preserved state for that mode

In match-filters.tsx:
1. Add `onModeChange` callback prop for mode switching
2. Extract availability toggle to its own handler that calls `onModeChange`
3. Keep other filter changes calling `onFiltersChange` as before

Alternative simpler approach (preferred):
- Keep single `filters` state but add `localStorage` persistence per mode
- When mode changes, save current filters to localStorage[currentMode], load filters from localStorage[newMode]
- This preserves state across mode switches AND browser sessions
  </action>
  <verify>
1. Select some filters in BetPawa mode (country, tournament, date range)
2. Switch to Competitor mode
3. Select different filters in Competitor mode
4. Switch back to BetPawa mode
5. Verify original BetPawa filters are restored
6. Verify Competitor filters are preserved when switching back
  </verify>
  <done>
Each availability mode has independent filter state that persists when switching modes
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] No 500 errors from API for any filter combination
- [ ] Country filter scopes correctly to availability mode
- [ ] Filter state preserved per availability mode when switching
- [ ] `npm run build` in web/ succeeds without errors
- [ ] No regressions in existing filter functionality
</verification>

<success_criteria>
- All UAT issues from 93-01-ISSUES.md addressed (UAT-003, UAT-004, UAT-005)
- Tests pass
- Ready for re-verification
</success_criteria>

<output>
After completion, create `.planning/phases/93-odds-comparison-page/93-01-FIX2-SUMMARY.md`
</output>
