---
phase: 13-database-schema-extension
plan: 01
type: execute
---

<objective>
Create database models for competitor tournaments, events, and odds snapshots.

Purpose: Enable storage of full competitor palimpsests (SportyBet, Bet9ja) independent of betpawa data, with SportRadar ID linkage for cross-platform matching.
Output: 5 new SQLAlchemy models in src/db/models/competitor.py with proper relationships and indexes.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-database-schema-extension/13-CONTEXT.md
@.planning/phases/02-database-schema/02-01-SUMMARY.md

# Existing models to reference for patterns:
@src/db/models/event.py
@src/db/models/sport.py
@src/db/models/odds.py
@src/db/models/scrape.py
@src/db/base.py

**Tech stack available:** SQLAlchemy 2.0, asyncpg, Pydantic v2
**Established patterns:**
- DeclarativeBase with MetaData(naming_convention)
- Mapped[] + mapped_column() for all columns
- back_populates for bidirectional relationships
- StrEnum for status/type fields
- server_default=func.now() for timestamps
- Index() for query optimization

**Constraining decisions:**
- Phase 2: sportradar_id as cross-platform matching key
- Phase context: Parallel tables with source column (not unified table)
- Phase context: Soft deletes via deleted_at for competitor data
- Phase context: Optional FK to betpawa event (NULL = competitor-only)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CompetitorSource enum and CompetitorTournament model</name>
  <files>src/db/models/competitor.py</files>
  <action>
Create new file src/db/models/competitor.py with:

1. CompetitorSource StrEnum with values: SPORTYBET, BET9JA

2. CompetitorTournament model:
   - id (primary key)
   - source (CompetitorSource enum, String(20))
   - sport_id (FK to sports.id)
   - name (String(255))
   - country_raw (String(100), nullable) - raw name from platform
   - country_iso (String(3), nullable) - normalized ISO code
   - external_id (String(100)) - platform-specific tournament ID
   - sportradar_id (String(100), nullable) - optional SR ID if available
   - created_at (server_default=func.now())
   - deleted_at (datetime, nullable) - soft delete

3. Add relationship to Sport model (one Sport has many CompetitorTournaments)

4. Add unique constraint on (source, external_id) - each platform's tournament ID is unique per source

5. Add indexes:
   - idx_competitor_tournaments_source on source
   - idx_competitor_tournaments_sport on sport_id
   - idx_competitor_tournaments_sr_id on sportradar_id (partial, where not null)

Follow existing patterns from sport.py - use Mapped[], mapped_column(), TYPE_CHECKING imports for relationships.
  </action>
  <verify>python -c "from src.db.models.competitor import CompetitorSource, CompetitorTournament; print('OK')"</verify>
  <done>CompetitorSource enum and CompetitorTournament model importable with all fields and indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create CompetitorEvent model with SR ID linkage</name>
  <files>src/db/models/competitor.py</files>
  <action>
Add CompetitorEvent model to competitor.py:

1. CompetitorEvent model:
   - id (primary key)
   - source (CompetitorSource enum, String(20))
   - tournament_id (FK to competitor_tournaments.id)
   - betpawa_event_id (FK to events.id, nullable) - NULL = competitor-only, set when matched
   - name (String(500))
   - home_team (String(255))
   - away_team (String(255))
   - kickoff (datetime)
   - external_id (String(100)) - platform-specific event ID
   - sportradar_id (String(100)) - SR ID for matching (required)
   - created_at (server_default=func.now())
   - updated_at (server_default=func.now(), onupdate=func.now())
   - deleted_at (datetime, nullable) - soft delete

2. Relationships:
   - tournament → CompetitorTournament (back_populates="events")
   - betpawa_event → Event (nullable, for cross-platform linkage)

3. Add back_populates="events" to CompetitorTournament

4. Unique constraint on (source, external_id) - each platform's event ID is unique per source

5. Indexes:
   - idx_competitor_events_source on source
   - idx_competitor_events_tournament on tournament_id
   - idx_competitor_events_sr_id on sportradar_id
   - idx_competitor_events_betpawa on betpawa_event_id (partial, where not null)
   - idx_competitor_events_kickoff on kickoff
  </action>
  <verify>python -c "from src.db.models.competitor import CompetitorEvent; print(CompetitorEvent.__tablename__)"</verify>
  <done>CompetitorEvent model with SR ID linkage, optional betpawa FK, and soft delete support</done>
</task>

<task type="auto">
  <name>Task 3: Create CompetitorOddsSnapshot and CompetitorMarketOdds models</name>
  <files>src/db/models/competitor.py, src/db/models/__init__.py</files>
  <action>
Add odds models to competitor.py:

1. CompetitorOddsSnapshot model (parallel to OddsSnapshot):
   - id (BigInteger primary key)
   - competitor_event_id (FK to competitor_events.id)
   - captured_at (server_default=func.now())
   - scrape_run_id (FK to scrape_runs.id, nullable)
   - raw_response (JSON, nullable)
   - Relationships: competitor_event, scrape_run, markets
   - Indexes: idx on competitor_event_id, idx on captured_at

2. CompetitorMarketOdds model (parallel to MarketOdds):
   - id (BigInteger primary key)
   - snapshot_id (BigInteger FK to competitor_odds_snapshots.id)
   - betpawa_market_id (String(50)) - normalized market ID
   - betpawa_market_name (String(255))
   - line (float, nullable)
   - handicap_type (String(50), nullable)
   - handicap_home (float, nullable)
   - handicap_away (float, nullable)
   - outcomes (JSON)
   - Relationship: snapshot → CompetitorOddsSnapshot
   - Indexes: idx on snapshot_id, idx on betpawa_market_id

3. Update src/db/models/__init__.py to export all new models:
   - CompetitorSource
   - CompetitorTournament
   - CompetitorEvent
   - CompetitorOddsSnapshot
   - CompetitorMarketOdds

Follow existing patterns from odds.py exactly - same column types, same JSON structure for outcomes.
  </action>
  <verify>python -c "from src.db.models import CompetitorSource, CompetitorTournament, CompetitorEvent, CompetitorOddsSnapshot, CompetitorMarketOdds; print('All exports OK')"</verify>
  <done>All 5 competitor models created, exported, and importable from src.db.models</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from src.db.models import CompetitorSource, CompetitorTournament, CompetitorEvent, CompetitorOddsSnapshot, CompetitorMarketOdds"` succeeds
- [ ] All models have proper Mapped[] type hints
- [ ] All relationships use back_populates
- [ ] All FK constraints defined
- [ ] All indexes defined
- [ ] Soft delete (deleted_at) on CompetitorTournament and CompetitorEvent
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No import errors
- Models follow established SQLAlchemy 2.0 patterns from Phase 2
- Ready for Plan 13-02 (migration creation)
</success_criteria>

<output>
After completion, create `.planning/phases/13-database-schema-extension/13-01-SUMMARY.md`
</output>
