---
phase: 49-market-grouping
plan: 01
type: execute
---

<objective>
Add market group data from Betpawa's API to the database and expose via API, then organize event detail markets into tabbed groups.

Purpose: Transform the flat market list into an organized, navigable interface using Betpawa's actual tab categories (not keyword guessing), with competitor-only tabs.
Output: Backend stores and exposes market_group field; frontend displays tabbed UI with Betpawa groups, competitor-only tabs, and "All Markets" view.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/49-market-grouping/49-CONTEXT.md

# Backend source files:
@src/db/models/odds.py
@src/scraping/event_coordinator.py
@src/matching/schemas.py
@src/api/routes/events.py

# Frontend source files:
@web/src/features/matches/index.tsx
@web/src/features/matches/components/market-grid.tsx
@web/src/features/matches/components/market-row.tsx
@web/src/types/api.ts

**Betpawa API structure:**
Markets have `marketType.tabs` array like `["all", "specials"]`, `["all", "goals"]`, `["all", "main"]`.
The first non-"all" tab is the market's primary group category.

**Requirements from CONTEXT.md:**
- Pill/badge style tabs with market counts
- Per-competitor tabs for unmatched markets
- "All Markets" view is grouped-but-expanded (headers visible, nothing collapsed)
- Use Betpawa's actual tab groups, no keyword guessing
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add market_group to database and API</name>
  <files>
    src/db/models/odds.py,
    src/db/models/competitor.py,
    src/scraping/event_coordinator.py,
    src/matching/schemas.py,
    src/api/routes/events.py,
    web/src/types/api.ts
  </files>
  <action>
**1. Add market_group column to MarketOdds model** (`src/db/models/odds.py`):
```python
market_group: Mapped[str | None] = mapped_column(String(50), nullable=True)
```

**2. Add same column to CompetitorMarketOdds** (`src/db/models/competitor.py`):
```python
market_group: Mapped[str | None] = mapped_column(String(50), nullable=True)
```

**3. Create Alembic migration:**
```bash
cd src && alembic revision --autogenerate -m "add market_group to odds tables"
```

**4. Modify `_parse_betpawa_markets()` in event_coordinator.py** to extract group:
```python
# After getting market_type
tabs = market_type.get("tabs", [])
# Get first non-"all" tab as the primary group, or "other" if only "all"
market_group = next((t for t in tabs if t != "all"), tabs[0] if tabs else "other")

# Add to MarketOdds creation
market_odds = MarketOdds(
    betpawa_market_id=str(market_id),
    betpawa_market_name=market_type.get("displayName", ""),
    line=line_value,
    outcomes=outcomes,
    market_group=market_group,  # NEW
)
```

**5. For competitor markets**, set market_group to None (they'll inherit from matched Betpawa market or show in competitor-only tab).

**6. Add market_group to MarketOddsDetail schema** (`src/matching/schemas.py`):
```python
class MarketOddsDetail(BaseModel):
    betpawa_market_id: str
    betpawa_market_name: str
    line: float | None
    outcomes: list[OutcomeDetail]
    margin: float | None
    market_group: str | None = None  # NEW
```

**7. Update `_build_market_detail()` in events.py** to include market_group:
```python
return MarketOddsDetail(
    betpawa_market_id=market.betpawa_market_id,
    betpawa_market_name=market.betpawa_market_name,
    line=market.line,
    outcomes=outcomes,
    margin=margin,
    market_group=market.market_group,  # NEW
)
```
Same for `_build_competitor_market_detail()`.

**8. Update frontend TypeScript types** (`web/src/types/api.ts`):
```typescript
export interface MarketOddsDetail {
  betpawa_market_id: string
  betpawa_market_name: string
  line: number | null
  outcomes: MarketOutcome[]
  margin: number
  market_group: string | null  // NEW
}
```

**9. Run migration:**
```bash
cd src && alembic upgrade head
```
  </action>
  <verify>
    - `cd src && alembic upgrade head` succeeds
    - `cd web && npm run build` passes (TypeScript types updated)
    - Backend starts without errors
  </verify>
  <done>
    - market_group column exists in market_odds and competitor_market_odds tables
    - Betpawa parser extracts tabs and stores primary group
    - API response includes market_group field
    - Frontend types updated
    - Migration applied successfully
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tabbed market view component</name>
  <files>
    web/src/features/matches/components/market-tabs.tsx,
    web/src/features/matches/components/market-grid.tsx,
    web/src/features/matches/components/index.ts,
    web/src/features/matches/index.tsx
  </files>
  <action>
**1. Export UnifiedMarket type from market-grid.tsx** (move interface to top and export it).

**2. Create `market-tabs.tsx`:**

```typescript
import { useMemo, useState } from 'react'
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs'
import { Badge } from '@/components/ui/badge'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import type { BookmakerMarketData } from '@/types/api'
import { MarketGrid, buildUnifiedMarkets, type UnifiedMarket } from './market-grid'

// Display config for Betpawa tabs
const GROUP_CONFIG: Record<string, { label: string; order: number }> = {
  main: { label: 'Main', order: 0 },
  popular: { label: 'Popular', order: 1 },
  goals: { label: 'Goals', order: 2 },
  corners: { label: 'Corners', order: 3 },
  cards: { label: 'Cards', order: 4 },
  specials: { label: 'Specials', order: 5 },
  halves: { label: 'Halves', order: 6 },
  players: { label: 'Players', order: 7 },
  // Fallback for unknown groups
}

function getGroupLabel(group: string): string {
  return GROUP_CONFIG[group]?.label ?? group.charAt(0).toUpperCase() + group.slice(1)
}

function getGroupOrder(group: string): number {
  return GROUP_CONFIG[group]?.order ?? 99
}

interface MarketTabsProps {
  marketsByBookmaker: BookmakerMarketData[]
}

export function MarketTabs({ marketsByBookmaker }: MarketTabsProps) {
  const unifiedMarkets = useMemo(
    () => buildUnifiedMarkets(marketsByBookmaker),
    [marketsByBookmaker]
  )

  // Group markets by their market_group (from Betpawa data)
  const { groupedMarkets, competitorOnly, sortedGroups } = useMemo(() => {
    const grouped = new Map<string, UnifiedMarket[]>()
    const sportyOnly: UnifiedMarket[] = []
    const bet9jaOnly: UnifiedMarket[] = []

    for (const market of unifiedMarkets) {
      const betpawaMarket = market.bookmakerMarkets.get('betpawa')

      if (!betpawaMarket) {
        // Competitor-only market
        const hasSporty = market.bookmakerMarkets.get('sportybet')
        const hasBet9ja = market.bookmakerMarkets.get('bet9ja')
        if (hasSporty && !hasBet9ja) sportyOnly.push(market)
        else if (hasBet9ja && !hasSporty) bet9jaOnly.push(market)
        else if (hasSporty) sportyOnly.push(market) // Both have it, show in sporty
        continue
      }

      // Use market_group from API, default to 'other'
      const group = (betpawaMarket as any).market_group || 'other'
      if (!grouped.has(group)) grouped.set(group, [])
      grouped.get(group)!.push(market)
    }

    // Sort groups by order
    const sorted = Array.from(grouped.entries()).sort(
      ([a], [b]) => getGroupOrder(a) - getGroupOrder(b)
    )

    return {
      groupedMarkets: grouped,
      competitorOnly: { sportybet: sportyOnly, bet9ja: bet9jaOnly },
      sortedGroups: sorted,
    }
  }, [unifiedMarkets])

  // Build tabs list
  const tabs = useMemo(() => {
    const result: { id: string; label: string; count: number }[] = []

    // Betpawa group tabs
    for (const [group, markets] of sortedGroups) {
      if (markets.length > 0) {
        result.push({ id: group, label: getGroupLabel(group), count: markets.length })
      }
    }

    // Competitor-only tabs
    if (competitorOnly.sportybet.length > 0) {
      result.push({ id: 'sportybet-only', label: 'SportyBet Only', count: competitorOnly.sportybet.length })
    }
    if (competitorOnly.bet9ja.length > 0) {
      result.push({ id: 'bet9ja-only', label: 'Bet9ja Only', count: competitorOnly.bet9ja.length })
    }

    // All Markets tab
    result.push({ id: 'all', label: 'All Markets', count: unifiedMarkets.length })

    return result
  }, [sortedGroups, competitorOnly, unifiedMarkets])

  const [activeTab, setActiveTab] = useState(tabs[0]?.id || 'all')

  // Get markets for current tab
  const getMarketsForTab = (tabId: string): UnifiedMarket[] => {
    if (tabId === 'all') return unifiedMarkets
    if (tabId === 'sportybet-only') return competitorOnly.sportybet
    if (tabId === 'bet9ja-only') return competitorOnly.bet9ja
    return groupedMarkets.get(tabId) || []
  }

  if (unifiedMarkets.length === 0) {
    return (
      <Card>
        <CardContent className="py-8">
          <div className="text-center text-muted-foreground">
            No market data available for this match.
          </div>
        </CardContent>
      </Card>
    )
  }

  return (
    <Card>
      <CardHeader className="pb-2">
        <CardTitle className="text-lg">Markets</CardTitle>
      </CardHeader>
      <CardContent>
        <Tabs value={activeTab} onValueChange={setActiveTab}>
          <TabsList className="flex flex-wrap gap-2 h-auto bg-transparent p-0 mb-4">
            {tabs.map((tab) => (
              <TabsTrigger
                key={tab.id}
                value={tab.id}
                className="rounded-full px-3 py-1.5 border data-[state=active]:bg-primary data-[state=active]:text-primary-foreground data-[state=active]:border-primary"
              >
                {tab.label}
                <Badge variant="secondary" className="ml-1.5 text-xs">
                  {tab.count}
                </Badge>
              </TabsTrigger>
            ))}
          </TabsList>

          {/* Tab content */}
          {tabs.map((tab) => (
            <TabsContent key={tab.id} value={tab.id} className="mt-0">
              {tab.id === 'all' ? (
                // All Markets: grouped with section headers
                <div className="space-y-6">
                  {sortedGroups.map(([group, markets]) => (
                    <div key={group}>
                      <h3 className="text-sm font-semibold text-muted-foreground mb-2 uppercase tracking-wide">
                        {getGroupLabel(group)} ({markets.length})
                      </h3>
                      <MarketGrid markets={markets} />
                    </div>
                  ))}
                  {competitorOnly.sportybet.length > 0 && (
                    <div>
                      <h3 className="text-sm font-semibold text-muted-foreground mb-2 uppercase tracking-wide">
                        SportyBet Only ({competitorOnly.sportybet.length})
                      </h3>
                      <MarketGrid markets={competitorOnly.sportybet} />
                    </div>
                  )}
                  {competitorOnly.bet9ja.length > 0 && (
                    <div>
                      <h3 className="text-sm font-semibold text-muted-foreground mb-2 uppercase tracking-wide">
                        Bet9ja Only ({competitorOnly.bet9ja.length})
                      </h3>
                      <MarketGrid markets={competitorOnly.bet9ja} />
                    </div>
                  )}
                </div>
              ) : (
                // Single group/category
                <MarketGrid markets={getMarketsForTab(tab.id)} />
              )}
            </TabsContent>
          ))}
        </Tabs>
      </CardContent>
    </Card>
  )
}
```

**3. Update MarketGrid to accept optional `markets` prop:**
- Add overload: `interface MarketGridProps { marketsByBookmaker?: BookmakerMarketData[]; markets?: UnifiedMarket[] }`
- If `markets` provided, use directly; else build from `marketsByBookmaker`
- Export `buildUnifiedMarkets` function

**4. Update index.ts** to export MarketTabs

**5. Update MatchDetail in index.tsx:**
- Replace the Card with "All Markets" title and MarketGrid
- Use `<MarketTabs marketsByBookmaker={event.markets_by_bookmaker} />`
  </action>
  <verify>
    - `cd web && npm run build` passes
    - Start dev server and navigate to event detail page
  </verify>
  <done>
    - MarketTabs component renders tabbed interface
    - Tabs use actual Betpawa group names from API
    - Pill/badge style tabs with market counts
    - Competitor-only tabs appear when applicable
    - "All Markets" tab shows grouped sections with headers
    - MarketGrid accepts either bookmaker data or pre-built markets
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Tabbed market grouping system using Betpawa's actual tab categories</what-built>
  <how-to-verify>
    1. Run: `cd web && npm run dev` (ensure backend is also running)
    2. Navigate to an event detail page (click any match from Odds Comparison)
    3. Verify tabs appear below the Quick Summary card
    4. Check tabs show actual Betpawa groups (Main, Goals, Specials, etc.) - NOT keyword-guessed categories
    5. Each tab should show count badge (e.g., "Goals (12)")
    6. Click different tabs - content should filter to that category
    7. Click "All Markets" tab - should show all markets organized by section headers
    8. If event has competitor-exclusive markets, verify "SportyBet Only" / "Bet9ja Only" tabs appear
    9. Verify empty categories don't show tabs
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Alembic migration applied successfully
- [ ] `cd web && npm run build` succeeds without errors
- [ ] API returns market_group field for Betpawa markets
- [ ] Tabs display with correct Betpawa group names
- [ ] Tab switching works correctly
- [ ] "All Markets" view shows grouped sections
- [ ] Competitor-only tabs work when applicable
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No TypeScript errors
- Database has market_group column
- API exposes market_group
- Tabbed market navigation uses actual Betpawa groups
- Competitor-only markets visible in dedicated tabs
</success_criteria>

<output>
After completion, create `.planning/phases/49-market-grouping/49-01-SUMMARY.md`:

# Phase 49-01: Market Grouping System Summary

**[One-liner describing what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for Phase 50 (Market Filtering)
</output>
