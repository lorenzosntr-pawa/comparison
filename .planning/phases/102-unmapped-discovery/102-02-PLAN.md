---
phase: 102-unmapped-discovery
plan: 02
type: execute
---

<objective>
Create API endpoints for unmapped markets and WebSocket alerts for new discoveries.

Purpose: Enable users to view, filter, and manage unmapped markets, with real-time alerts when new ones are discovered.
Output: REST API endpoints for unmapped markets CRUD + WebSocket alerts on new discoveries.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/100-investigation-design/DESIGN.md  # API contract spec
@.planning/phases/102-unmapped-discovery/102-01-SUMMARY.md

# Key files
@src/db/models/mapping.py  # UnmappedMarketLog model
@src/api/routes/mappings.py  # Existing mappings router to extend
@src/api/schemas/mappings.py  # Existing schemas (may need unmapped schemas)
@src/api/websocket/manager.py  # WebSocket manager with TOPICS
@src/market_mapping/unmapped_logger.py  # UnmappedLogger from 102-01

**Tech stack available:**
- FastAPI with Pydantic v2 schemas
- WebSocket manager with topic-based pub/sub
- SQLAlchemy async queries
- structlog for logging

**Established patterns:**
- CRUD endpoints with soft delete
- Paginated list responses
- WebSocket broadcast via ws_manager.broadcast(message, topic)
- Cache-first API reads (but unmapped uses DB since it's historical)

**Constraining decisions:**
- Phase 100 DESIGN.md: API contracts for GET /mappings/unmapped, GET /mappings/unmapped/{id}, PATCH /mappings/unmapped/{id}
- Status values: NEW, ACKNOWLEDGED, MAPPED, IGNORED
- v2.0: WebSocket manager at app.state.ws_manager
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unmapped markets API endpoints</name>
  <files>src/api/routes/unmapped.py, src/api/schemas/unmapped.py, src/api/app.py</files>
  <action>
1. **Create Pydantic schemas (src/api/schemas/unmapped.py):**

```python
"""Pydantic schemas for unmapped market discovery API."""

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, ConfigDict, Field
from pydantic.alias_generators import to_camel


class UnmappedMarketListItem(BaseModel):
    """Summary item for unmapped market list."""
    model_config = ConfigDict(
        from_attributes=True,
        alias_generator=to_camel,
        populate_by_name=True,
    )

    id: int
    source: str
    external_market_id: str
    market_name: Optional[str]
    first_seen_at: datetime
    last_seen_at: datetime
    occurrence_count: int
    status: str


class UnmappedMarketListResponse(BaseModel):
    """Paginated list of unmapped markets."""
    model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)

    items: list[UnmappedMarketListItem]
    total: int
    page: int
    page_size: int


class UnmappedMarketDetailResponse(BaseModel):
    """Full unmapped market details."""
    model_config = ConfigDict(
        from_attributes=True,
        alias_generator=to_camel,
        populate_by_name=True,
    )

    id: int
    source: str
    external_market_id: str
    market_name: Optional[str]
    sample_outcomes: Optional[list[dict]]
    first_seen_at: datetime
    last_seen_at: datetime
    occurrence_count: int
    status: str
    notes: Optional[str]


class UpdateUnmappedRequest(BaseModel):
    """Update unmapped market status."""
    model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)

    status: Optional[str] = Field(default=None, pattern="^(NEW|ACKNOWLEDGED|MAPPED|IGNORED)$")
    notes: Optional[str] = Field(default=None, max_length=1000)
```

2. **Create API router (src/api/routes/unmapped.py):**

Endpoints:
- GET /unmapped - List unmapped markets with filters (source, status, min_occurrences, sort_by, page, page_size)
- GET /unmapped/{id} - Get single unmapped market details
- PATCH /unmapped/{id} - Update status and/or notes

Follow pattern from mappings.py:
- Use Query() for filter params
- DB queries with select()
- Paginate results
- Return 404 for not found

3. **Register router in app.py:**
- Import: `from src.api.routes.unmapped import router as unmapped_router`
- Register: `app.include_router(unmapped_router, prefix="/api")`

Do NOT add stats endpoint yet - that's Phase 103.
  </action>
  <verify>curl http://localhost:8000/api/unmapped?page=1&page_size=10 (after starting server) OR python -c "from src.api.routes.unmapped import router; print('OK')"</verify>
  <done>3 endpoints for unmapped markets (list, detail, update). Router registered in app.py.</done>
</task>

<task type="auto">
  <name>Task 2: Add WebSocket topic and broadcast alerts</name>
  <files>src/api/websocket/manager.py, src/scraping/event_coordinator.py, src/api/websocket/messages.py</files>
  <action>
1. **Add unmapped_alerts topic (src/api/websocket/manager.py):**
   - Add "unmapped_alerts" to TOPICS set: `TOPICS = {"scrape_progress", "odds_updates", "unmapped_alerts"}`

2. **Create alert message builder (src/api/websocket/messages.py):**
   Add function:
   ```python
   def build_unmapped_alert(markets: list[dict]) -> dict:
       """Build WebSocket message for new unmapped markets.

       Args:
           markets: List of dicts with source, external_market_id, market_name.

       Returns:
           WebSocket message envelope.
       """
       return {
           "type": "unmapped_alert",
           "timestamp": datetime.now(timezone.utc).isoformat(),
           "data": {
               "count": len(markets),
               "markets": markets,
           },
       }
   ```

3. **Broadcast after flush in event_coordinator.py:**
   - After calling `unmapped_logger.flush(db)`:
   ```python
   # Broadcast WebSocket alert for new unmapped markets
   new_markets = unmapped_logger.get_new_markets()
   if new_markets and hasattr(app, 'state') and hasattr(app.state, 'ws_manager'):
       from src.api.websocket.messages import build_unmapped_alert
       alert = build_unmapped_alert([
           {"source": m.source, "externalMarketId": m.external_market_id, "marketName": m.market_name}
           for m in new_markets
       ])
       await app.state.ws_manager.broadcast(alert, "unmapped_alerts")
   unmapped_logger.clear_new_markets()
   ```

   Note: Need access to `app` in coordinator. Pass `ws_manager` as parameter or access via global.

   Alternative: Use callback pattern - coordinator emits event, app layer handles broadcast. But for simplicity, just pass ws_manager to coordinator or check if available.

   Simpler approach: Add optional `on_unmapped` callback to EventCoordinator, let app layer set it during lifespan.

4. **Actually, cleanest approach:**
   - In event_coordinator.py's flush location, broadcast via the stale_detection or jobs module pattern
   - OR: Just log for now, add WebSocket broadcast in separate task if complex

   Keep it simple: After flush, if new_count > 0, broadcast. Access ws_manager from app state if available.
  </action>
  <verify>grep -n "unmapped_alerts" src/api/websocket/manager.py && grep -n "build_unmapped_alert" src/api/websocket/messages.py</verify>
  <done>WebSocket topic added. Alert message builder created. Broadcast triggered after flush when new markets discovered.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] 3 API endpoints created and working
- [ ] Schemas follow project conventions (camelCase aliases)
- [ ] Router registered in app.py
- [ ] WebSocket topic "unmapped_alerts" added
- [ ] Alert message builder follows envelope pattern
- [ ] Broadcast happens after flush when new markets found
</verification>

<success_criteria>

- API endpoints list/detail/update unmapped markets
- WebSocket clients subscribed to "unmapped_alerts" receive notifications
- Alert includes count and market details (source, id, name)
- Phase 102 complete
</success_criteria>

<output>
After completion, create `.planning/phases/102-unmapped-discovery/102-02-SUMMARY.md`
</output>
