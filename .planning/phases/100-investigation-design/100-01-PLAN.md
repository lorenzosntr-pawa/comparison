---
phase: 100-investigation-design
plan: 01
type: execute
---

<objective>
Analyze current market mapping gaps and design the Market Mapping Utility architecture.

Purpose: Establish technical foundation for user-editable market mappings by analyzing current state, designing DB schema, and defining API contracts.
Output: INVESTIGATION.md (gap analysis) and DESIGN.md (schema, merge strategy, API contracts)
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-market-mapping-audit/43-01-SUMMARY.md
@.planning/phases/45-market-mapping-improvement-audit/45-01-SUMMARY.md

# Current market mapping architecture:
@src/market_mapping/mappings/market_ids.py (first 100 lines - structure)
@src/market_mapping/mappers/unified.py
@src/db/models/odds.py
@src/db/models/competitor.py

# Prior context:
- Phase 43 audit identified 380 unique unmapped market types
- Phase 45 improved SportyBet to 52.2%, Bet9ja to 40.5% mapping success
- Current architecture: static MARKET_MAPPINGS tuple in market_ids.py
- Competitor odds stored in competitor_market_odds with betpawa_market_id after mapping
- Unmapped markets currently logged as MappingError but not persisted

**Accumulated patterns:**
- Alembic migrations for schema changes
- Pydantic schemas for API contracts
- MARKET_MAPPINGS as frozen tuple of MarketMapping dataclasses
- find_by_* lookup functions for market resolution
</context>

<tasks>

<task type="auto">
  <name>Task 1: Current State Gap Analysis</name>
  <files>.planning/phases/100-investigation-design/INVESTIGATION.md</files>
  <action>
Run SQL queries to analyze current mapping gaps:

1. **Platform coverage metrics:**
```sql
-- Count total vs mapped markets by platform (from competitor_market_odds)
SELECT
  ce.source,
  COUNT(DISTINCT cmo.betpawa_market_id) as mapped_markets,
  COUNT(*) as total_market_rows
FROM competitor_market_odds cmo
JOIN competitor_odds_snapshots cos ON cmo.snapshot_id = cos.id
JOIN competitor_events ce ON cos.competitor_event_id = ce.id
WHERE cmo.betpawa_market_id IS NOT NULL
GROUP BY ce.source;
```

2. **Unmapped market patterns (from raw_response):**
- Query recent competitor_odds_snapshots.raw_response
- Extract market IDs not present in competitor_market_odds
- Group by frequency to identify priority gaps

3. **Market distribution analysis:**
- Which betpawa_market_ids have most competitor coverage
- Which betpawa_market_ids are competitor-only (no Betpawa equivalent)

Create INVESTIGATION.md documenting:
- Current mapping coverage statistics (update from Phase 45 numbers)
- Top 20 unmapped markets by occurrence frequency
- Platform-specific gaps (SportyBet-only, Bet9ja-only markets)
- Distribution of mapped vs unmapped by market category
  </action>
  <verify>INVESTIGATION.md exists with coverage statistics table and top unmapped markets list</verify>
  <done>Gap analysis complete with actionable priority list for Phase 101+</done>
</task>

<task type="auto">
  <name>Task 2: Architecture Design Document</name>
  <files>.planning/phases/100-investigation-design/DESIGN.md</files>
  <action>
Create comprehensive design document covering:

**1. Database Schema (3 new tables):**

```
user_market_mappings
- id: SERIAL PRIMARY KEY
- canonical_id: VARCHAR(100) UNIQUE NOT NULL (e.g., "1x2_ft")
- name: VARCHAR(255) NOT NULL
- betpawa_id: VARCHAR(50)
- sportybet_id: VARCHAR(50)
- bet9ja_key: VARCHAR(50)
- outcome_mapping: JSONB NOT NULL (array of outcome objects)
- priority: INTEGER DEFAULT 0 (higher = preferred over code)
- is_active: BOOLEAN DEFAULT TRUE
- created_at: TIMESTAMPTZ DEFAULT NOW()
- updated_at: TIMESTAMPTZ DEFAULT NOW()
- created_by: VARCHAR(100) (future: user tracking)

mapping_audit_log
- id: SERIAL PRIMARY KEY
- mapping_id: INTEGER REFERENCES user_market_mappings(id)
- action: VARCHAR(20) NOT NULL (CREATE, UPDATE, DELETE, ACTIVATE, DEACTIVATE)
- old_value: JSONB (previous state)
- new_value: JSONB (new state)
- reason: TEXT
- created_at: TIMESTAMPTZ DEFAULT NOW()
- created_by: VARCHAR(100)

unmapped_market_log
- id: SERIAL PRIMARY KEY
- source: VARCHAR(20) NOT NULL (sportybet, bet9ja)
- external_market_id: VARCHAR(100) NOT NULL
- market_name: VARCHAR(255)
- sample_outcomes: JSONB (example outcome structure)
- first_seen_at: TIMESTAMPTZ DEFAULT NOW()
- last_seen_at: TIMESTAMPTZ
- occurrence_count: INTEGER DEFAULT 1
- status: VARCHAR(20) DEFAULT 'NEW' (NEW, ACKNOWLEDGED, MAPPED, IGNORED)
- UNIQUE(source, external_market_id)
```

**2. Runtime Merge Strategy:**
- Load order: Code MARKET_MAPPINGS (base) â†’ DB user_market_mappings (overrides)
- Merge key: canonical_id (DB overrides code if same canonical_id)
- Active flag: DB mappings can be deactivated without deletion
- Priority field: For future multiple DB mappings with same betpawa_id
- Caching: Merged mappings cached at startup, invalidated on DB change
- Hot reload: API endpoint to trigger re-merge without restart

**3. API Contract Specification:**

CRUD Endpoints:
- GET /api/mappings - List all mappings (merged view)
  - Query params: source, is_active, search
  - Response: MappingListResponse with merged code+DB mappings

- GET /api/mappings/{canonical_id} - Get single mapping
  - Response: MappingDetailResponse with source indicator (code/db)

- POST /api/mappings - Create user mapping
  - Body: CreateMappingRequest (canonical_id, name, platform IDs, outcomes)
  - Response: MappingResponse
  - Side effect: Writes audit log

- PATCH /api/mappings/{canonical_id} - Update user mapping
  - Body: UpdateMappingRequest (partial update)
  - Response: MappingResponse
  - Side effect: Writes audit log with old/new values

- DELETE /api/mappings/{canonical_id} - Soft delete (deactivate)
  - Response: 204 No Content
  - Side effect: Sets is_active=false, writes audit log

Discovery Endpoints:
- GET /api/mappings/unmapped - List unmapped markets
  - Query params: source, status, min_occurrences, sort_by
  - Response: UnmappedMarketListResponse

- GET /api/mappings/unmapped/{id} - Get unmapped market details
  - Response: UnmappedMarketDetailResponse with sample data

- POST /api/mappings/unmapped/{id}/acknowledge - Mark as acknowledged
  - Side effect: Updates status

Analysis Endpoints:
- GET /api/mappings/stats - Coverage statistics
  - Response: MappingStatsResponse (totals, by-platform breakdowns)

- GET /api/mappings/audit-log - Audit history
  - Query params: mapping_id, action, from_date, to_date
  - Response: AuditLogListResponse

- POST /api/mappings/reload - Trigger merge cache reload
  - Response: 200 OK with new mapping count

**4. Pydantic Schemas (outline):**
Define request/response schemas for each endpoint following existing patterns in src/api/schemas/
  </action>
  <verify>DESIGN.md exists with all 4 sections: DB schema, merge strategy, API contracts, Pydantic outline</verify>
  <done>Technical specification complete, ready for Phase 101 implementation</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] INVESTIGATION.md has current coverage statistics
- [ ] INVESTIGATION.md lists top 20 unmapped markets with frequency
- [ ] DESIGN.md has complete DB schema for all 3 tables
- [ ] DESIGN.md documents runtime merge strategy
- [ ] DESIGN.md specifies all API endpoints with request/response shapes
- [ ] Design aligns with existing codebase patterns (Alembic, Pydantic, SQLAlchemy)
</verification>

<success_criteria>

- Both documents created and committed
- Gap analysis provides actionable priority list
- Schema design is implementation-ready for Phase 101
- API contracts are specific enough for frontend planning
- No ambiguity remaining for implementation phases
</success_criteria>

<output>
After completion, create `.planning/phases/100-investigation-design/100-01-SUMMARY.md`:

# Phase 100 Plan 01: Investigation & Design Summary

**[One-liner summarizing key findings and design decisions]**

## Accomplishments

- [Coverage statistics findings]
- [Top unmapped market discoveries]
- [Schema design highlights]
- [API design approach]

## Files Created/Modified

- `.planning/phases/100-investigation-design/INVESTIGATION.md`
- `.planning/phases/100-investigation-design/DESIGN.md`

## Decisions Made

[Key design decisions and rationale]

## Issues Encountered

[Any blockers or concerns discovered]

## Next Phase Readiness

Ready for Phase 101: Backend Foundation - implement DB tables and merge logic
</output>
