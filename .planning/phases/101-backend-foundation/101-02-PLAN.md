---
phase: 101-backend-foundation
plan: 02
type: execute
---

<objective>
Implement MappingCache with runtime merge logic for code + DB mappings.

Purpose: Enable fast mapping lookups by caching merged code and user-defined mappings in memory with hot reload capability.
Output: MappingCache class with merge logic, integrated into app startup via lifespan event.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/100-investigation-design/DESIGN.md
@.planning/phases/101-backend-foundation/101-01-PLAN.md
@src/market_mapping/market_ids.py
@src/caching/odds_cache.py
@src/api/main.py

**From Phase 100 DESIGN.md:**
- MappingCache class with frozen CachedMapping dataclass
- Load order: code MARKET_MAPPINGS → DB user_market_mappings → merge → build indexes
- Merge rule: DB overrides code on matching canonical_id
- Multiple lookup indexes: by_betpawa, by_sportybet, by_bet9ja
- Async lock for thread-safe reload
- find_by_bet9ja_key uses prefix matching

**Established patterns:**
- Frozen dataclasses for cache entries (from OddsCache in v2.0)
- asyncio.Lock for cache operations
- Cache warmup in app lifespan (from OddsCache pattern)
- perf_counter timing for startup metrics
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MappingCache with merge logic</name>
  <files>src/market_mapping/cache.py</files>
  <action>
Create new file src/market_mapping/cache.py with:

**Frozen dataclass for cached entries:**
```python
from dataclasses import dataclass
from typing import Optional, Dict
from datetime import datetime
import asyncio

@dataclass(frozen=True)
class OutcomeMapping:
    """Single outcome mapping within a market."""
    canonical_id: str
    betpawa_name: Optional[str]
    sportybet_desc: Optional[str]
    bet9ja_suffix: Optional[str]
    position: int

@dataclass(frozen=True)
class CachedMapping:
    """Immutable cached mapping for thread-safe access."""
    canonical_id: str
    name: str
    betpawa_id: Optional[str]
    sportybet_id: Optional[str]
    bet9ja_key: Optional[str]
    outcome_mapping: tuple[OutcomeMapping, ...]  # Frozen tuple
    source: str  # "code" or "db"
    priority: int
```

**MappingCache class:**
```python
class MappingCache:
    """Thread-safe in-memory mapping cache with hot reload."""

    def __init__(self):
        self._mappings: Dict[str, CachedMapping] = {}
        self._by_betpawa: Dict[str, CachedMapping] = {}
        self._by_sportybet: Dict[str, CachedMapping] = {}
        self._by_bet9ja: Dict[str, CachedMapping] = {}
        self._lock = asyncio.Lock()
        self._loaded_at: Optional[datetime] = None
        self._count: int = 0

    async def load(self, session: AsyncSession) -> int:
        """Load and merge mappings from code and DB.

        Returns number of mappings loaded.
        """
        async with self._lock:
            # 1. Start with code mappings
            merged = {}
            for m in MARKET_MAPPINGS:
                cached = self._from_code(m)
                merged[cached.canonical_id] = cached

            # 2. Load DB mappings (active only)
            from src.api.models import UserMarketMapping
            result = await session.execute(
                select(UserMarketMapping).where(UserMarketMapping.is_active == True)
            )
            db_mappings = result.scalars().all()

            # 3. Merge: DB overrides code on same canonical_id
            for db_map in db_mappings:
                cached = self._from_db(db_map)
                merged[cached.canonical_id] = cached

            # 4. Build indexes
            self._mappings = merged
            self._by_betpawa = {m.betpawa_id: m for m in merged.values() if m.betpawa_id}
            self._by_sportybet = {m.sportybet_id: m for m in merged.values() if m.sportybet_id}
            self._by_bet9ja = {m.bet9ja_key: m for m in merged.values() if m.bet9ja_key}
            self._loaded_at = datetime.utcnow()
            self._count = len(merged)

            return self._count

    def _from_code(self, mapping: MarketMapping) -> CachedMapping:
        """Convert code mapping to CachedMapping."""
        outcomes = tuple(
            OutcomeMapping(
                canonical_id=o.canonical_id,
                betpawa_name=o.betpawa_name,
                sportybet_desc=o.sportybet_desc,
                bet9ja_suffix=o.bet9ja_suffix,
                position=o.position,
            )
            for o in mapping.outcomes
        )
        return CachedMapping(
            canonical_id=mapping.canonical_id,
            name=mapping.name,
            betpawa_id=mapping.betpawa_id,
            sportybet_id=mapping.sportybet_id,
            bet9ja_key=mapping.bet9ja_key,
            outcome_mapping=outcomes,
            source="code",
            priority=0,
        )

    def _from_db(self, mapping: UserMarketMapping) -> CachedMapping:
        """Convert DB mapping to CachedMapping."""
        outcomes = tuple(
            OutcomeMapping(
                canonical_id=o.get("canonical_id", ""),
                betpawa_name=o.get("betpawa_name"),
                sportybet_desc=o.get("sportybet_desc"),
                bet9ja_suffix=o.get("bet9ja_suffix"),
                position=o.get("position", 0),
            )
            for o in (mapping.outcome_mapping or [])
        )
        return CachedMapping(
            canonical_id=mapping.canonical_id,
            name=mapping.name,
            betpawa_id=mapping.betpawa_id,
            sportybet_id=mapping.sportybet_id,
            bet9ja_key=mapping.bet9ja_key,
            outcome_mapping=outcomes,
            source="db",
            priority=mapping.priority,
        )

    def find_by_canonical_id(self, id: str) -> Optional[CachedMapping]:
        """Find mapping by canonical_id."""
        return self._mappings.get(id)

    def find_by_betpawa_id(self, id: str) -> Optional[CachedMapping]:
        """Find mapping by BetPawa market ID."""
        return self._by_betpawa.get(id)

    def find_by_sportybet_id(self, id: str) -> Optional[CachedMapping]:
        """Find mapping by SportyBet market ID."""
        return self._by_sportybet.get(id)

    def find_by_bet9ja_key(self, key: str) -> Optional[CachedMapping]:
        """Find mapping by Bet9ja key using prefix matching."""
        for prefix, mapping in self._by_bet9ja.items():
            if key.startswith(prefix):
                return mapping
        return None

    def get_all(self) -> list[CachedMapping]:
        """Get all cached mappings."""
        return list(self._mappings.values())

    @property
    def loaded_at(self) -> Optional[datetime]:
        """When cache was last loaded."""
        return self._loaded_at

    @property
    def count(self) -> int:
        """Number of mappings in cache."""
        return self._count
```

**Module-level singleton:**
```python
# Global singleton instance
mapping_cache = MappingCache()
```

Import MARKET_MAPPINGS from src.market_mapping.market_ids.
Import select from sqlalchemy.
Import AsyncSession from sqlalchemy.ext.asyncio.
  </action>
  <verify>cd src && python -c "from market_mapping.cache import mapping_cache, CachedMapping, OutcomeMapping; print('Cache module imported successfully')"</verify>
  <done>MappingCache class with merge logic, lookup methods, and singleton instance</done>
</task>

<task type="auto">
  <name>Task 2: Integrate cache into app startup</name>
  <files>src/api/main.py</files>
  <action>
Modify the existing lifespan context manager in main.py to:

1. Import mapping_cache from src.market_mapping.cache
2. After OddsCache warmup (but before scheduler start), add MappingCache warmup:

```python
# Warm up mapping cache
from src.market_mapping.cache import mapping_cache
import time

mapping_start = time.perf_counter()
async with get_session() as session:
    mapping_count = await mapping_cache.load(session)
mapping_ms = (time.perf_counter() - mapping_start) * 1000
logger.info(f"MappingCache warmed: {mapping_count} mappings in {mapping_ms:.1f}ms")
```

3. Store mapping_cache on app.state for access in routes:
```python
app.state.mapping_cache = mapping_cache
```

Follow the existing pattern from OddsCache warmup - use perf_counter for timing, log with structlog.
Place the mapping cache warmup AFTER database pool creation but BEFORE scheduler start.
  </action>
  <verify>cd src/api && python -c "import asyncio; from main import app; print('App imports successfully with mapping cache')"</verify>
  <done>MappingCache warmup in app lifespan, accessible via app.state.mapping_cache</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cd src && python -c "from market_mapping.cache import mapping_cache"` succeeds
- [ ] App starts without errors and logs mapping cache warmup
- [ ] `app.state.mapping_cache` is accessible in app context
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- MappingCache loads code mappings at startup
- Cache warmup timing logged via structlog
- No import errors or circular dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/101-backend-foundation/101-02-SUMMARY.md`
</output>
