---
phase: 101-backend-foundation
plan: 03
type: execute
---

<objective>
Create Pydantic schemas and CRUD API endpoints for market mappings.

Purpose: Expose mapping management functionality through RESTful API with proper request/response validation.
Output: Pydantic schemas (mappings.py) and FastAPI router with CRUD endpoints + hot reload.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/100-investigation-design/DESIGN.md
@.planning/phases/101-backend-foundation/101-01-PLAN.md
@.planning/phases/101-backend-foundation/101-02-PLAN.md
@src/api/schemas/odds.py
@src/api/routers/odds.py

**From Phase 100 DESIGN.md:**
- Complete Pydantic schema outlines for all request/response types
- CRUD endpoints: GET list, GET detail, POST create, PATCH update, DELETE soft-delete
- Hot reload endpoint: POST /api/mappings/reload
- Audit log creation on all mutations
- camelCase aliases for frontend compatibility

**Established patterns:**
- ConfigDict with from_attributes=True, alias_generator=to_camel, populate_by_name=True
- Field descriptions and validation constraints
- Pagination pattern with items/total/page/page_size
- Depends(get_db) for database session injection
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for mappings API</name>
  <files>src/api/schemas/mappings.py</files>
  <action>
Create new file src/api/schemas/mappings.py with all schemas from DESIGN.md section 4:

**Imports:**
```python
from datetime import datetime
from typing import Optional
from pydantic import BaseModel, ConfigDict, Field
from pydantic.alias_generators import to_camel
```

**Outcome Mapping Schema:**
```python
class OutcomeMappingSchema(BaseModel):
    """Single outcome mapping within a market."""
    model_config = ConfigDict(
        alias_generator=to_camel,
        populate_by_name=True,
    )

    canonical_id: str = Field(description="Canonical outcome identifier")
    betpawa_name: Optional[str] = Field(default=None)
    sportybet_desc: Optional[str] = Field(default=None)
    bet9ja_suffix: Optional[str] = Field(default=None)
    position: int = Field(description="Display order position")
```

**Mapping List/Detail Responses:**
```python
class MappingListItem(BaseModel):
    """Summary item for mapping list."""
    model_config = ConfigDict(
        from_attributes=True,
        alias_generator=to_camel,
        populate_by_name=True,
    )

    canonical_id: str
    name: str
    betpawa_id: Optional[str] = None
    sportybet_id: Optional[str] = None
    bet9ja_key: Optional[str] = None
    outcome_count: int
    source: str  # "code" or "db"
    is_active: bool = True
    priority: int = 0


class MappingListResponse(BaseModel):
    """Paginated list of mappings."""
    model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)

    items: list[MappingListItem]
    total: int
    page: int
    page_size: int


class MappingDetailResponse(BaseModel):
    """Full mapping details."""
    model_config = ConfigDict(
        from_attributes=True,
        alias_generator=to_camel,
        populate_by_name=True,
    )

    canonical_id: str
    name: str
    betpawa_id: Optional[str] = None
    sportybet_id: Optional[str] = None
    bet9ja_key: Optional[str] = None
    outcome_mapping: list[OutcomeMappingSchema]
    source: str
    is_active: bool = True
    priority: int = 0
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
```

**Mapping Requests:**
```python
class CreateMappingRequest(BaseModel):
    """Create new user mapping."""
    model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)

    canonical_id: str = Field(min_length=1, max_length=100)
    name: str = Field(min_length=1, max_length=255)
    betpawa_id: Optional[str] = Field(default=None, max_length=50)
    sportybet_id: Optional[str] = Field(default=None, max_length=50)
    bet9ja_key: Optional[str] = Field(default=None, max_length=50)
    outcome_mapping: list[OutcomeMappingSchema]
    priority: int = Field(default=0, ge=0, le=100)
    reason: Optional[str] = Field(default=None, max_length=500)


class UpdateMappingRequest(BaseModel):
    """Partial update for user mapping."""
    model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)

    name: Optional[str] = Field(default=None, max_length=255)
    betpawa_id: Optional[str] = Field(default=None, max_length=50)
    sportybet_id: Optional[str] = Field(default=None, max_length=50)
    bet9ja_key: Optional[str] = Field(default=None, max_length=50)
    outcome_mapping: Optional[list[OutcomeMappingSchema]] = None
    priority: Optional[int] = Field(default=None, ge=0, le=100)
    is_active: Optional[bool] = None
    reason: Optional[str] = Field(default=None, max_length=500)
```

**Reload Response:**
```python
class ReloadResponse(BaseModel):
    """Response for cache reload."""
    model_config = ConfigDict(alias_generator=to_camel, populate_by_name=True)

    status: str
    mapping_count: int
    reloaded_at: datetime
```

Follow existing patterns in src/api/schemas/odds.py for consistency.
  </action>
  <verify>cd src/api && python -c "from schemas.mappings import MappingListResponse, CreateMappingRequest, MappingDetailResponse; print('Schemas imported successfully')"</verify>
  <done>All Pydantic schemas created with proper validation and camelCase aliases</done>
</task>

<task type="auto">
  <name>Task 2: Create CRUD API router with hot reload</name>
  <files>src/api/routers/mappings.py, src/api/main.py</files>
  <action>
**Step 1: Create src/api/routers/mappings.py:**

```python
"""Market mapping CRUD API endpoints.

Provides endpoints for:
- Listing merged mappings (code + DB)
- Getting mapping details
- Creating user-defined mappings
- Updating user mappings
- Soft-deleting (deactivating) user mappings
- Hot reload of mapping cache
"""

from datetime import datetime
from typing import Optional
from fastapi import APIRouter, Depends, HTTPException, Query, Request
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession

from src.api.database import get_db
from src.api.models import UserMarketMapping, MappingAuditLog
from src.api.schemas.mappings import (
    MappingListResponse,
    MappingListItem,
    MappingDetailResponse,
    CreateMappingRequest,
    UpdateMappingRequest,
    OutcomeMappingSchema,
    ReloadResponse,
)
from src.market_mapping.cache import mapping_cache

router = APIRouter(prefix="/mappings", tags=["mappings"])


@router.get("", response_model=MappingListResponse)
async def list_mappings(
    request: Request,
    source: Optional[str] = Query(None, description="Filter by source: code, db"),
    search: Optional[str] = Query(None, description="Search in canonical_id and name"),
    platform: Optional[str] = Query(None, description="Filter by platform support"),
    page: int = Query(1, ge=1),
    page_size: int = Query(50, ge=1, le=100),
):
    """List all mappings (merged view of code + DB)."""
    all_mappings = mapping_cache.get_all()

    # Apply filters
    filtered = all_mappings
    if source:
        filtered = [m for m in filtered if m.source == source]
    if search:
        search_lower = search.lower()
        filtered = [m for m in filtered if search_lower in m.canonical_id.lower() or search_lower in m.name.lower()]
    if platform:
        if platform == "betpawa":
            filtered = [m for m in filtered if m.betpawa_id]
        elif platform == "sportybet":
            filtered = [m for m in filtered if m.sportybet_id]
        elif platform == "bet9ja":
            filtered = [m for m in filtered if m.bet9ja_key]

    # Paginate
    total = len(filtered)
    start = (page - 1) * page_size
    end = start + page_size
    page_items = filtered[start:end]

    items = [
        MappingListItem(
            canonical_id=m.canonical_id,
            name=m.name,
            betpawa_id=m.betpawa_id,
            sportybet_id=m.sportybet_id,
            bet9ja_key=m.bet9ja_key,
            outcome_count=len(m.outcome_mapping),
            source=m.source,
            is_active=True,  # Cached mappings are always active
            priority=m.priority,
        )
        for m in page_items
    ]

    return MappingListResponse(items=items, total=total, page=page, page_size=page_size)


@router.get("/{canonical_id}", response_model=MappingDetailResponse)
async def get_mapping(canonical_id: str):
    """Get single mapping with full details."""
    mapping = mapping_cache.find_by_canonical_id(canonical_id)
    if not mapping:
        raise HTTPException(status_code=404, detail=f"Mapping not found: {canonical_id}")

    return MappingDetailResponse(
        canonical_id=mapping.canonical_id,
        name=mapping.name,
        betpawa_id=mapping.betpawa_id,
        sportybet_id=mapping.sportybet_id,
        bet9ja_key=mapping.bet9ja_key,
        outcome_mapping=[
            OutcomeMappingSchema(
                canonical_id=o.canonical_id,
                betpawa_name=o.betpawa_name,
                sportybet_desc=o.sportybet_desc,
                bet9ja_suffix=o.bet9ja_suffix,
                position=o.position,
            )
            for o in mapping.outcome_mapping
        ],
        source=mapping.source,
        is_active=True,
        priority=mapping.priority,
        created_at=None,  # Code mappings don't have timestamps
        updated_at=None,
    )


@router.post("", response_model=MappingDetailResponse, status_code=201)
async def create_mapping(
    request: CreateMappingRequest,
    db: AsyncSession = Depends(get_db),
):
    """Create new user mapping."""
    # Check if canonical_id already exists in DB
    existing = await db.execute(
        select(UserMarketMapping).where(UserMarketMapping.canonical_id == request.canonical_id)
    )
    if existing.scalar_one_or_none():
        raise HTTPException(status_code=400, detail=f"Mapping already exists: {request.canonical_id}")

    # Create mapping
    mapping = UserMarketMapping(
        canonical_id=request.canonical_id,
        name=request.name,
        betpawa_id=request.betpawa_id,
        sportybet_id=request.sportybet_id,
        bet9ja_key=request.bet9ja_key,
        outcome_mapping=[o.model_dump() for o in request.outcome_mapping],
        priority=request.priority,
        is_active=True,
    )
    db.add(mapping)

    # Create audit log
    audit = MappingAuditLog(
        canonical_id=request.canonical_id,
        action="CREATE",
        old_value=None,
        new_value=mapping_to_dict(mapping),
        reason=request.reason,
    )
    db.add(audit)

    await db.commit()
    await db.refresh(mapping)

    # Reload cache
    await mapping_cache.load(db)

    return mapping_to_response(mapping)


@router.patch("/{canonical_id}", response_model=MappingDetailResponse)
async def update_mapping(
    canonical_id: str,
    request: UpdateMappingRequest,
    db: AsyncSession = Depends(get_db),
):
    """Update existing user mapping (partial update)."""
    # Check if code-only mapping (can't update)
    cached = mapping_cache.find_by_canonical_id(canonical_id)
    if cached and cached.source == "code":
        # Check if DB override exists
        result = await db.execute(
            select(UserMarketMapping).where(UserMarketMapping.canonical_id == canonical_id)
        )
        mapping = result.scalar_one_or_none()
        if not mapping:
            raise HTTPException(status_code=400, detail="Cannot update code-only mapping. Create a DB override instead.")
    else:
        result = await db.execute(
            select(UserMarketMapping).where(UserMarketMapping.canonical_id == canonical_id)
        )
        mapping = result.scalar_one_or_none()
        if not mapping:
            raise HTTPException(status_code=404, detail=f"Mapping not found: {canonical_id}")

    # Store old value for audit
    old_value = mapping_to_dict(mapping)

    # Apply updates
    update_data = request.model_dump(exclude_unset=True, exclude={"reason"})
    if "outcome_mapping" in update_data and update_data["outcome_mapping"] is not None:
        update_data["outcome_mapping"] = [o.model_dump() if hasattr(o, "model_dump") else o for o in update_data["outcome_mapping"]]

    for field, value in update_data.items():
        setattr(mapping, field, value)

    # Create audit log
    audit = MappingAuditLog(
        mapping_id=mapping.id,
        canonical_id=canonical_id,
        action="UPDATE",
        old_value=old_value,
        new_value=mapping_to_dict(mapping),
        reason=request.reason,
    )
    db.add(audit)

    await db.commit()
    await db.refresh(mapping)

    # Reload cache
    await mapping_cache.load(db)

    return mapping_to_response(mapping)


@router.delete("/{canonical_id}", status_code=204)
async def delete_mapping(
    canonical_id: str,
    reason: Optional[str] = Query(None, description="Reason for deletion"),
    db: AsyncSession = Depends(get_db),
):
    """Soft delete (deactivate) user mapping."""
    # Check if code-only mapping
    cached = mapping_cache.find_by_canonical_id(canonical_id)
    if cached and cached.source == "code":
        result = await db.execute(
            select(UserMarketMapping).where(UserMarketMapping.canonical_id == canonical_id)
        )
        if not result.scalar_one_or_none():
            raise HTTPException(status_code=400, detail="Cannot delete code-only mapping")

    result = await db.execute(
        select(UserMarketMapping).where(UserMarketMapping.canonical_id == canonical_id)
    )
    mapping = result.scalar_one_or_none()
    if not mapping:
        raise HTTPException(status_code=404, detail=f"Mapping not found: {canonical_id}")

    # Soft delete
    old_value = mapping_to_dict(mapping)
    mapping.is_active = False

    # Create audit log
    audit = MappingAuditLog(
        mapping_id=mapping.id,
        canonical_id=canonical_id,
        action="DEACTIVATE",
        old_value=old_value,
        new_value=mapping_to_dict(mapping),
        reason=reason,
    )
    db.add(audit)

    await db.commit()

    # Reload cache
    await mapping_cache.load(db)

    return None


@router.post("/reload", response_model=ReloadResponse)
async def reload_mappings(db: AsyncSession = Depends(get_db)):
    """Hot reload mapping cache from code + DB."""
    count = await mapping_cache.load(db)
    return ReloadResponse(
        status="ok",
        mapping_count=count,
        reloaded_at=mapping_cache.loaded_at or datetime.utcnow(),
    )


def mapping_to_dict(mapping: UserMarketMapping) -> dict:
    """Convert mapping to dict for audit log."""
    return {
        "canonical_id": mapping.canonical_id,
        "name": mapping.name,
        "betpawa_id": mapping.betpawa_id,
        "sportybet_id": mapping.sportybet_id,
        "bet9ja_key": mapping.bet9ja_key,
        "outcome_mapping": mapping.outcome_mapping,
        "priority": mapping.priority,
        "is_active": mapping.is_active,
    }


def mapping_to_response(mapping: UserMarketMapping) -> MappingDetailResponse:
    """Convert DB mapping to response."""
    return MappingDetailResponse(
        canonical_id=mapping.canonical_id,
        name=mapping.name,
        betpawa_id=mapping.betpawa_id,
        sportybet_id=mapping.sportybet_id,
        bet9ja_key=mapping.bet9ja_key,
        outcome_mapping=[
            OutcomeMappingSchema(**o) if isinstance(o, dict) else o
            for o in (mapping.outcome_mapping or [])
        ],
        source="db",
        is_active=mapping.is_active,
        priority=mapping.priority,
        created_at=mapping.created_at,
        updated_at=mapping.updated_at,
    )
```

**Step 2: Register router in src/api/main.py:**

Add import at top:
```python
from src.api.routers.mappings import router as mappings_router
```

Add router registration after other routers (near odds_router, settings_router):
```python
app.include_router(mappings_router, prefix="/api")
```
  </action>
  <verify>cd src/api && python -c "from routers.mappings import router; print(f'Router has {len(router.routes)} routes')" && curl -s http://localhost:8000/api/mappings?page_size=1 2>/dev/null || echo "Server not running (expected)"</verify>
  <done>CRUD router with 6 endpoints: list, detail, create, update, delete, reload</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All Pydantic schemas import without errors
- [ ] Router imports without errors
- [ ] App starts without errors
- [ ] `GET /api/mappings` returns paginated list
- [ ] `POST /api/mappings/reload` triggers cache reload
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- No Python import errors
- API endpoints respond correctly
- Cache reload works via API
</success_criteria>

<output>
After completion, create `.planning/phases/101-backend-foundation/101-03-SUMMARY.md`
</output>
