---
phase: 01-market-mapping-port
plan: 01
type: execute
---

<objective>
Port TypeScript type definitions to Python Pydantic v2 models with error handling.

Purpose: Establish the foundational data structures that all mappers and the registry depend on.
Output: Complete `src/market_mapping/types/` package with Pydantic models for all input/output types.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-market-mapping-port/01-RESEARCH.md
@.planning/phases/01-market-mapping-port/01-CONTEXT.md

# TypeScript source files to port:
@mapping_markets/src/types/errors.ts
@mapping_markets/src/types/normalized.ts
@mapping_markets/src/types/mapped.ts
@mapping_markets/src/types/sportybet.ts
@mapping_markets/src/types/betpawa.ts
@mapping_markets/src/types/bet9ja.ts
@mapping_markets/src/types/competitors.ts

**Key patterns from research:**
- Use Pydantic v2 `model_config = ConfigDict(frozen=True)` for immutable models
- Use `StrEnum` for error codes (Python 3.11+)
- Use `Literal` types for discriminated unions
- Use `X | None` syntax instead of `Optional[X]`
- Skip Result pattern - use custom `MappingError` exception instead
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create package structure and error types</name>
  <files>src/market_mapping/__init__.py, src/market_mapping/types/__init__.py, src/market_mapping/types/errors.py</files>
  <action>
Create the Python package structure:
```
src/market_mapping/
├── __init__.py           # Empty for now, will export public API later
├── types/
│   ├── __init__.py       # Export all types
│   └── errors.py         # Error enum and exception
```

In `errors.py`:
- Port `MappingErrorCode` enum using `StrEnum` (not regular Enum)
- Create `MappingError` exception class (NOT a Pydantic model) with:
  - `code: MappingErrorCode`
  - `message: str`
  - `context: dict[str, Any] | None`
- Include `__str__` method that formats nicely

DO NOT use the TypeScript Result pattern. Python convention is exceptions.
  </action>
  <verify>python -c "from market_mapping.types.errors import MappingErrorCode, MappingError; print(MappingErrorCode.UNKNOWN_MARKET)"</verify>
  <done>MappingErrorCode enum has all 7 error codes, MappingError exception can be raised with code and message</done>
</task>

<task type="auto">
  <name>Task 2: Port normalized and mapped types</name>
  <files>src/market_mapping/types/normalized.py, src/market_mapping/types/mapped.py</files>
  <action>
Port from TypeScript `normalized.ts` and `mapped.ts`:

In `normalized.py`:
- `SourcePlatform` as `Literal["betpawa", "sportybet", "bet9ja"]`
- `SpecifierType` as `Literal["total", "handicap", "goalnr", "score", "other"]`
- `NormalizedSpecifier` Pydantic model (frozen)
- `NormalizedOutcome` Pydantic model (frozen)
- `NormalizedMarket` Pydantic model (frozen)
- `OutcomeMapping` Pydantic model (frozen) - for market registry
- `MarketMapping` Pydantic model (frozen) - for market registry

In `mapped.py`:
- `MappedOutcome` Pydantic model (frozen)
- `MappedHandicap` Pydantic model (frozen)
- `MappedMarket` Pydantic model (frozen)

Use `ConfigDict(frozen=True)` for all models. Use `tuple` instead of `list` for immutable sequences in frozen models.
  </action>
  <verify>python -c "from market_mapping.types.normalized import MarketMapping, OutcomeMapping; from market_mapping.types.mapped import MappedMarket; print('Types imported successfully')"</verify>
  <done>All normalized and mapped types importable, frozen models can be instantiated</done>
</task>

<task type="auto">
  <name>Task 3: Port platform-specific input types</name>
  <files>src/market_mapping/types/sportybet.py, src/market_mapping/types/betpawa.py, src/market_mapping/types/bet9ja.py, src/market_mapping/types/competitors.py</files>
  <action>
Port platform-specific types from TypeScript:

In `sportybet.py`:
- `SportybetOutcome` - outcome from Sportybet API
- `SportybetMarket` - market from Sportybet API
- `SportybetEvent` - event wrapper (optional, for context)

In `betpawa.py`:
- `BetpawaOutcome` - outcome from Betpawa API
- `BetpawaMarket` - market from Betpawa API
- `BetpawaEvent` - event wrapper

In `bet9ja.py`:
- `Bet9jaOdds` - the key-value odds format from Bet9ja

In `competitors.py`:
- `SportybetInput` with `source: Literal["sportybet"]`
- `Bet9jaInput` with `source: Literal["bet9ja"]`
- `CompetitorInput` as discriminated union using `Annotated[Union[...], Field(discriminator="source")]`

These models should NOT be frozen - they're input data that gets validated. Use regular Pydantic models.

Update `types/__init__.py` to export all types.
  </action>
  <verify>python -c "from market_mapping.types import SportybetInput, Bet9jaInput, CompetitorInput; print('All types exported')"</verify>
  <done>All platform types importable, CompetitorInput discriminated union works correctly</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from market_mapping.types import *"` succeeds
- [ ] All 7 MappingErrorCode values accessible
- [ ] MappingError can be raised and caught
- [ ] Frozen models reject mutation attempts
- [ ] CompetitorInput correctly discriminates between SportybetInput and Bet9jaInput
</verification>

<success_criteria>

- All type definitions ported from TypeScript
- Pydantic v2 syntax used throughout (ConfigDict, not class Config)
- StrEnum for error codes
- Discriminated union for CompetitorInput
- All models importable from `market_mapping.types`
</success_criteria>

<output>
After completion, create `.planning/phases/01-market-mapping-port/01-01-SUMMARY.md`
</output>
