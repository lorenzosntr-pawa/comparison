---
phase: 01-market-mapping-port
plan: 05
type: execute
---

<objective>
Port the Bet9ja to Betpawa mapper to Python.

Purpose: Enable transformation of Bet9ja market data into Betpawa's format for comparison.
Output: Complete `src/market_mapping/mappers/bet9ja.py` with all mapping logic.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-market-mapping-port/01-RESEARCH.md

# Prior plan summaries:
@.planning/phases/01-market-mapping-port/01-01-SUMMARY.md
@.planning/phases/01-market-mapping-port/01-02-SUMMARY.md
@.planning/phases/01-market-mapping-port/01-03-SUMMARY.md
@.planning/phases/01-market-mapping-port/01-04-SUMMARY.md

# TypeScript source to port:
@mapping_markets/src/mappers/bet9ja-to-betpawa.ts

**Key patterns:**
- Bet9ja uses key-value pairs like {"S_1X2_1": "1.50", "S_1X2_X": "3.20", "S_1X2_2": "2.10"}
- Keys are parsed to extract market type, param (for O/U), and outcome suffix
- Group outcomes by market, then map each market
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port Bet9ja key grouping and outcome matching</name>
  <files>src/market_mapping/mappers/bet9ja.py</files>
  <action>
Create `bet9ja.py` with grouping and matching logic:

1. Import dependencies:
```python
from ..types.bet9ja import Bet9jaOdds
from ..types.mapped import MappedMarket, MappedOutcome, MappedHandicap
from ..types.normalized import OutcomeMapping, MarketMapping
from ..types.errors import MappingError, MappingErrorCode
from ..mappings import find_by_bet9ja_key
from ..utils import parse_bet9ja_key, ParsedBet9jaKey
```

2. Create type for grouped outcomes:
```python
@dataclass
class GroupedBet9jaMarket:
    market_key: str  # e.g., "S_1X2"
    param: str | None  # e.g., "2.5" for O/U
    outcomes: dict[str, str]  # outcome_suffix -> odds string
```

3. Group function:
```python
def _group_by_market(odds: dict[str, str]) -> list[GroupedBet9jaMarket]:
    # Parse each key with parse_bet9ja_key
    # Group by (market_key, param) tuple
    # Return list of GroupedBet9jaMarket
```

4. Outcome matching function:
```python
def _match_outcome(
    outcome_suffix: str,
    odds_str: str,
    outcome_mappings: tuple[OutcomeMapping, ...],
) -> MappedOutcome | None:
    # Find mapping where bet9ja_suffix matches outcome_suffix
    # Parse odds string to float
    # Return MappedOutcome or None
```

Key logic:
- Match by `mapping.bet9ja_suffix` (exact match, not case-insensitive - Bet9ja keys are uppercase)
- Parse odds string to float, return None if invalid
  </action>
  <verify>python -c "from market_mapping.mappers.bet9ja import _group_by_market; print('Bet9ja grouping ready')"</verify>
  <done>_group_by_market correctly groups Bet9ja odds by market and param, _match_outcome finds outcomes by suffix</done>
</task>

<task type="auto">
  <name>Task 2: Port market mapping functions</name>
  <files>src/market_mapping/mappers/bet9ja.py</files>
  <action>
Add mapping functions to `bet9ja.py`:

1. Single market mapper:
```python
def _map_bet9ja_market(
    grouped: GroupedBet9jaMarket,
    mapping: MarketMapping,
) -> MappedMarket:
    # Map all outcomes using _match_outcome
    # Handle param for O/U markets (line value)
    # Raise MappingError if no outcomes matched
    # Return MappedMarket
```

2. Main entry point for single market:
```python
def map_bet9ja_market_to_betpawa(
    market_key: str,
    param: str | None,
    outcomes: dict[str, str],
) -> MappedMarket:
    """
    Map a single Bet9ja market to Betpawa format.

    Args:
        market_key: The market key (e.g., "S_1X2", "S_OU")
        param: Optional parameter (e.g., "2.5" for O/U line)
        outcomes: Dict of outcome_suffix -> odds_string

    Raises:
        MappingError: If market cannot be mapped
    """
```

3. Batch entry point for full odds dict:
```python
def map_bet9ja_odds_to_betpawa(
    odds: dict[str, str],
) -> list[MappedMarket]:
    """
    Map all Bet9ja odds to Betpawa format.

    Args:
        odds: Full Bet9ja odds dict with keys like "S_1X2_1"

    Returns:
        List of successfully mapped markets (skips unmappable markets)
    """
    # Group by market
    # Map each grouped market
    # Collect successful mappings (log/skip failures)
```

Handle error cases:
- UNKNOWN_MARKET: No mapping for market_key
- UNSUPPORTED_PLATFORM: Mapping exists but betpawa_id is None
- INVALID_KEY_FORMAT: Key doesn't match expected pattern
- NO_MATCHING_OUTCOMES: No outcomes could be matched
- INVALID_ODDS: Odds string couldn't be parsed

Update `mappers/__init__.py` to export `map_bet9ja_market_to_betpawa` and `map_bet9ja_odds_to_betpawa`.
  </action>
  <verify>python -c "from market_mapping.mappers import map_bet9ja_odds_to_betpawa; print('Bet9ja mapper ready')"</verify>
  <done>map_bet9ja_odds_to_betpawa handles full odds dict, map_bet9ja_market_to_betpawa handles single market with proper error handling</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `{"S_1X2_1": "1.50", "S_1X2_X": "3.20", "S_1X2_2": "2.10"}` maps to 1X2 market with 3 outcomes
- [ ] `{"S_OU@2.5_O": "1.80", "S_OU@2.5_U": "2.00"}` maps to O/U market with line=2.5
- [ ] Unknown market key raises MappingError
- [ ] Invalid key format raises INVALID_KEY_FORMAT
- [ ] Batch mapper returns list of mapped markets, skipping failures
</verification>

<success_criteria>

- Bet9ja key grouping works correctly
- All market types supported (simple, parameterized)
- Error handling matches TypeScript behavior
- Batch mapping returns partial results on mixed success/failure
</success_criteria>

<output>
After completion, create `.planning/phases/01-market-mapping-port/01-05-SUMMARY.md`
</output>
