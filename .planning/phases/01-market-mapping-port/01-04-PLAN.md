---
phase: 01-market-mapping-port
plan: 04
type: execute
---

<objective>
Port the Sportybet to Betpawa mapper to Python.

Purpose: Enable transformation of Sportybet market data into Betpawa's format for comparison.
Output: Complete `src/market_mapping/mappers/sportybet.py` with all mapping logic.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-market-mapping-port/01-RESEARCH.md

# Prior plan summaries:
@.planning/phases/01-market-mapping-port/01-01-SUMMARY.md
@.planning/phases/01-market-mapping-port/01-02-SUMMARY.md
@.planning/phases/01-market-mapping-port/01-03-SUMMARY.md

# TypeScript source to port:
@mapping_markets/src/mappers/sportybet-to-betpawa.ts

**Key patterns from research:**
- Raise MappingError exceptions instead of returning Result types
- Use `.lower()` for case-insensitive outcome matching
- Handle None betpawa_id (UNSUPPORTED_PLATFORM error)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port outcome mapping logic</name>
  <files>src/market_mapping/mappers/__init__.py, src/market_mapping/mappers/sportybet.py</files>
  <action>
Start `sportybet.py` with outcome mapping functions:

1. Import dependencies:
```python
from ..types.sportybet import SportybetMarket, SportybetOutcome
from ..types.mapped import MappedMarket, MappedOutcome, MappedHandicap
from ..types.normalized import OutcomeMapping
from ..types.errors import MappingError, MappingErrorCode
from ..mappings import find_by_sportybet_id, is_over_under_market, is_handicap_market, is_variant_market
from ..utils import parse_specifier, parse_handicap
```

2. Outcome mapping function:
```python
def _map_outcome(
    outcome: SportybetOutcome,
    outcome_mappings: tuple[OutcomeMapping, ...],
    position: int,
) -> MappedOutcome | None:
    # Try to match by desc (case-insensitive)
    # Fall back to position matching
    # Return MappedOutcome or None if no match
```

Key logic:
- Match `outcome.desc.lower()` against `mapping.sportybet_desc.lower()`
- If no match by desc, try matching by position
- Parse odds string to float (handle invalid odds)
- Return None if no mapping found (don't raise - caller handles)
  </action>
  <verify>python -c "from market_mapping.mappers.sportybet import _map_outcome; print('Outcome mapper imported')"</verify>
  <done>_map_outcome function correctly matches outcomes by description with case-insensitive comparison</done>
</task>

<task type="auto">
  <name>Task 2: Port market mapping functions</name>
  <files>src/market_mapping/mappers/sportybet.py</files>
  <action>
Add the main mapping functions to `sportybet.py`:

1. Simple market mapper (1X2, Double Chance, BTTS, etc.):
```python
def _map_simple_market(
    market: SportybetMarket,
    mapping: MarketMapping,
) -> MappedMarket:
    # Map all outcomes
    # Raise MappingError if no outcomes matched
    # Return MappedMarket
```

2. Over/Under market mapper:
```python
def _map_over_under_market(
    market: SportybetMarket,
    mapping: MarketMapping,
) -> MappedMarket:
    # Parse specifier for total (line value)
    # Map outcomes with line in result
    # Return MappedMarket with line field set
```

3. Handicap market mapper:
```python
def _map_handicap_market(
    market: SportybetMarket,
    mapping: MarketMapping,
) -> MappedMarket:
    # Parse specifier for hcp
    # Parse handicap string to home/away values
    # Map outcomes with handicap in result
    # Return MappedMarket with handicap field set
```

4. Variant market mapper (exact goals, winning margin):
```python
def _map_variant_market(
    market: SportybetMarket,
    mapping: MarketMapping,
) -> MappedMarket:
    # Similar to simple but may have variant specifier
    # The variant value doesn't affect outcome matching
```

5. Main entry point:
```python
def map_sportybet_to_betpawa(market: SportybetMarket) -> MappedMarket:
    """
    Map a Sportybet market to Betpawa format.

    Raises:
        MappingError: If market cannot be mapped (unknown market, unsupported platform, etc.)
    """
    # Find mapping by sportybet_id
    # Check betpawa_id is not None
    # Dispatch to appropriate mapper based on market type
```

Handle all error cases:
- UNKNOWN_MARKET: No mapping found for sportybet_id
- UNSUPPORTED_PLATFORM: Mapping exists but betpawa_id is None
- INVALID_SPECIFIER: Specifier present but unparseable
- NO_MATCHING_OUTCOMES: All outcomes failed to match

Update `mappers/__init__.py` to export `map_sportybet_to_betpawa`.
  </action>
  <verify>python -c "from market_mapping.mappers import map_sportybet_to_betpawa; print('Sportybet mapper ready')"</verify>
  <done>map_sportybet_to_betpawa handles all market types (simple, O/U, handicap, variant) and raises appropriate MappingError on failure</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Simple market (1X2) maps correctly with 3 outcomes
- [ ] Over/Under market includes line value (e.g., 2.5)
- [ ] Handicap market includes handicap values
- [ ] Unknown market ID raises MappingError with UNKNOWN_MARKET code
- [ ] Market with null betpawa_id raises UNSUPPORTED_PLATFORM
- [ ] Invalid odds string raises INVALID_ODDS
</verification>

<success_criteria>

- All market types from TypeScript mapper supported
- MappingError raised with appropriate error codes
- Outcome matching is case-insensitive
- Line and handicap values extracted from specifiers
</success_criteria>

<output>
After completion, create `.planning/phases/01-market-mapping-port/01-04-SUMMARY.md`
</output>
