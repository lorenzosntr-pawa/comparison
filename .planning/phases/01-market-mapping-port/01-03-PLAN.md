---
phase: 01-market-mapping-port
plan: 03
type: execute
---

<objective>
Port the specifier parser and Bet9ja key parser utilities to Python.

Purpose: Provide parsing utilities needed by the mappers to handle parameterized markets.
Output: Complete `src/market_mapping/utils/` package with parsers.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-market-mapping-port/01-RESEARCH.md

# Prior plan summaries:
@.planning/phases/01-market-mapping-port/01-01-SUMMARY.md
@.planning/phases/01-market-mapping-port/01-02-SUMMARY.md

# TypeScript source to port:
@mapping_markets/src/utils/specifier-parser.ts
@mapping_markets/src/utils/bet9ja-parser.ts

**Key patterns from research:**
- Pre-compile regex patterns at module level for performance
- Use frozen dataclasses for parsed results
- Include ReDoS prevention (max length checks)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Port specifier parser</name>
  <files>src/market_mapping/utils/__init__.py, src/market_mapping/utils/specifier_parser.py</files>
  <action>
Port from TypeScript `specifier-parser.ts`:

In `specifier_parser.py`:
1. Pre-compile regex at module level:
```python
SPECIFIER_PATTERN = re.compile(r"([a-z]+)=([^|]+)")
```

2. Create frozen dataclass for parsed result:
```python
@dataclass(frozen=True)
class ParsedSpecifier:
    total: float | None = None
    hcp: str | None = None
    variant: str | None = None
    goalnr: int | None = None
    score: str | None = None
    raw: str = ""
```

3. Create `ParsedHandicap` dataclass for handicap parsing:
```python
@dataclass(frozen=True)
class ParsedHandicap:
    home: float
    away: float
```

4. Main parse function:
```python
def parse_specifier(specifier: str | None) -> ParsedSpecifier:
    # ReDoS prevention: reject strings > 1000 chars
    # Parse key=value pairs from specifier string
    # Return ParsedSpecifier with extracted values
```

5. Handicap parse function:
```python
def parse_handicap(hcp_string: str | None) -> ParsedHandicap | None:
    # Parse "0:1" format into home/away floats
    # Handle negative handicaps
```

Port the exact logic from TypeScript, including all edge cases.
  </action>
  <verify>python -c "from market_mapping.utils.specifier_parser import parse_specifier, parse_handicap; p = parse_specifier('total=2.5|variant=sr:over_under'); print(f'total={p.total}')"</verify>
  <done>parse_specifier extracts total, hcp, variant, goalnr, score correctly; parse_handicap handles "0:1" format</done>
</task>

<task type="auto">
  <name>Task 2: Port Bet9ja key parser</name>
  <files>src/market_mapping/utils/bet9ja_parser.py</files>
  <action>
Port from TypeScript `bet9ja-parser.ts`:

In `bet9ja_parser.py`:
1. Pre-compile regex at module level:
```python
BET9JA_KEY_PATTERN = re.compile(r"^S_([A-Z0-9_\-]+?)(?:@([^_]+))?_(.+)$")
```

2. Create frozen dataclass for parsed result:
```python
@dataclass(frozen=True)
class ParsedBet9jaKey:
    market: str      # e.g., "1X2", "OU", "DC"
    param: str | None  # e.g., "2.5" for O/U lines
    outcome: str     # e.g., "1", "X", "2", "O", "U"
```

3. Main parse function:
```python
def parse_bet9ja_key(key: str) -> ParsedBet9jaKey | None:
    # Match against pattern
    # Return None if no match
    # Return ParsedBet9jaKey with extracted parts
```

Examples to handle:
- `S_1X2_1` → market="1X2", param=None, outcome="1"
- `S_OU@2.5_O` → market="OU", param="2.5", outcome="O"
- `S_DC_1X` → market="DC", param=None, outcome="1X"
- `S_GGNG_Y` → market="GGNG", param=None, outcome="Y"

Update `utils/__init__.py` to export all parsers.
  </action>
  <verify>python -c "from market_mapping.utils import parse_bet9ja_key; p = parse_bet9ja_key('S_OU@2.5_O'); print(f'market={p.market}, param={p.param}, outcome={p.outcome}')"</verify>
  <done>parse_bet9ja_key correctly parses all Bet9ja key formats including parameterized markets</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `parse_specifier("total=2.5")` returns ParsedSpecifier with total=2.5
- [ ] `parse_specifier("hcp=0:1")` returns ParsedSpecifier with hcp="0:1"
- [ ] `parse_handicap("0:1")` returns ParsedHandicap(home=0.0, away=1.0)
- [ ] `parse_bet9ja_key("S_1X2_1")` returns market="1X2", outcome="1"
- [ ] `parse_bet9ja_key("S_OU@2.5_O")` returns market="OU", param="2.5", outcome="O"
- [ ] Very long strings (>1000 chars) don't cause ReDoS
</verification>

<success_criteria>

- Both parsers ported with all edge cases
- Regex patterns pre-compiled at module level
- Frozen dataclasses for return types
- ReDoS prevention in place
</success_criteria>

<output>
After completion, create `.planning/phases/01-market-mapping-port/01-03-SUMMARY.md`
</output>
