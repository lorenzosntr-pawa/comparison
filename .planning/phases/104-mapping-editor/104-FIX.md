---
phase: 104-mapping-editor
plan: FIX
type: fix
---

<objective>
Fix 3 UAT issues from Phase 104 Mapping Editor verification.

Source: 104-ISSUES.md
Priority: 2 blockers (UAT-001, UAT-002), 1 major (UAT-003)

The critical fix is UAT-001: integrating MappingCache with the mappers so user-created mappings are actually used during scraping. Without this, the entire Phase 104 feature has no effect.

UAT-002 adds a browsable mapping list UI so users can view/edit existing mappings.
UAT-003 is addressed by UAT-001 - once MappingCache is integrated, new unmapped markets discovered after scraping will use user mappings.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/104-mapping-editor/104-ISSUES.md

**Key files for UAT-001:**
@src/market_mapping/cache.py
@src/market_mapping/mappers/sportybet.py
@src/market_mapping/mappers/bet9ja.py
@src/market_mapping/mappings/market_ids.py
@src/scraping/event_coordinator.py
@src/scraping/competitor_events.py

**Key files for UAT-002:**
@web/src/features/mappings/components/high-priority-unmapped.tsx
@web/src/features/mappings/editor/index.tsx
</context>

<tasks>
<task type="auto">
  <name>Task 1: Replace module-level lookups with MappingCache singleton</name>
  <files>
    src/market_mapping/mappings/market_ids.py
    src/market_mapping/cache.py
  </files>
  <action>
The mappers use `find_by_sportybet_id()` and `find_by_bet9ja_key()` from market_ids.py which return hardcoded MarketMapping objects. The MappingCache already has these methods with the same signatures but returns CachedMapping.

**Strategy: Module-level singleton with lazy initialization**

1. In cache.py, add a module-level singleton:
```python
_mapping_cache: Optional[MappingCache] = None

def get_mapping_cache() -> MappingCache:
    """Get global mapping cache singleton. Must be initialized first."""
    if _mapping_cache is None:
        raise RuntimeError("MappingCache not initialized. Call init_mapping_cache() first.")
    return _mapping_cache

async def init_mapping_cache(session: AsyncSession) -> MappingCache:
    """Initialize global mapping cache singleton."""
    global _mapping_cache
    _mapping_cache = MappingCache()
    await _mapping_cache.load(session)
    return _mapping_cache
```

2. In market_ids.py, modify lookup functions to delegate to cache when available:
```python
from src.market_mapping.cache import get_mapping_cache

def find_by_sportybet_id(market_id: str) -> MarketMapping | None:
    """Find mapping by SportyBet ID - uses cache if available, falls back to hardcoded."""
    try:
        cache = get_mapping_cache()
        cached = cache.find_by_sportybet_id(market_id)
        if cached:
            # Convert CachedMapping to MarketMapping for backward compat
            return _cached_to_market_mapping(cached)
        return None
    except RuntimeError:
        # Cache not initialized, use hardcoded (startup path)
        return _BY_SPORTYBET_ID.get(market_id)
```

3. Add `_cached_to_market_mapping()` helper to convert CachedMapping → MarketMapping.

4. Update app lifespan to call `init_mapping_cache()` after DB warmup.

**Critical: This maintains backward compatibility.** Before cache init (app startup), hardcoded mappings work. After init, cache takes over with merged code+DB mappings.
  </action>
  <verify>
1. `npm run build` (frontend) and backend starts without errors
2. Create a test user mapping via API
3. Run scrape and verify new mapping is used (check logs for mapped market)
  </verify>
  <done>
- Module-level singleton initialized during app startup
- find_by_sportybet_id() and find_by_bet9ja_key() delegate to cache when available
- User-created mappings from user_market_mappings table are applied during scraping
  </done>
</task>

<task type="auto">
  <name>Task 2: Add existing mappings browser to dashboard</name>
  <files>
    web/src/features/mappings/components/existing-mappings.tsx
    web/src/features/mappings/hooks/use-mappings.ts
    web/src/features/mappings/index.tsx
  </files>
  <action>
Add a section to the Mapping Dashboard showing all existing mappings (code + user) with ability to edit user mappings.

1. Create `existing-mappings.tsx` component:
   - Table with columns: Canonical ID, Name, BetPawa ID, SportyBet ID, Bet9ja Key, Source (code/user), Actions
   - Search/filter by name or canonical ID
   - For user mappings: Edit button linking to editor
   - For code mappings: "Override" button to create user mapping with same canonical ID (higher priority)
   - Use existing shadcn Table component

2. Create `use-mappings.ts` hook:
   - GET /api/mappings already exists and returns all mappings
   - Add search parameter support if not already present
   - Return { mappings, isLoading, error }

3. Update dashboard `index.tsx`:
   - Add "Existing Mappings" section below stats cards
   - Include the ExistingMappings component
   - Tab layout: "All" | "Code" | "User" to filter by source

**Navigation to editor:**
- For user mappings: `/mappings/editor/existing/{canonicalId}` (new route)
- For override: `/mappings/editor/override/{canonicalId}` (pre-fills from code mapping)

4. Update routes.tsx to add new editor routes.

5. Update editor/index.tsx to handle:
   - `/editor/:unmappedId` (existing - from unmapped)
   - `/editor/existing/:canonicalId` (edit user mapping)
   - `/editor/override/:canonicalId` (create override of code mapping)
  </action>
  <verify>
1. Dashboard shows "Existing Mappings" section with all 129+ mappings
2. Search filters work
3. Click Edit on user mapping → editor loads with existing data
4. Click Override on code mapping → editor loads in "Create New" mode pre-filled
  </verify>
  <done>
- Existing mappings visible and searchable on dashboard
- User mappings editable via editor
- Code mappings can be overridden with user mappings
- Both edit and override flows work end-to-end
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify integration with scraping pipeline</name>
  <files>
    src/scraping/event_coordinator.py
    src/scraping/competitor_events.py
  </files>
  <action>
Verify the scraping pipeline now uses MappingCache lookups correctly.

1. Check event_coordinator.py imports and ensure MappingCache is accessible
2. Check competitor_events.py imports
3. Add debug logging to confirm cache lookups are happening:
   - Log when cache is used vs fallback
   - Log cache hit/miss for unmapped market detection

4. Verify UnmappedLogger still works:
   - When cache returns None → MappingError raised → UnmappedLogger.log() called
   - This fixes UAT-003 indirectly

**No structural changes needed** - the mapper functions are already called, we just changed what they delegate to internally.
  </action>
  <verify>
1. Start backend, observe "MappingCache initialized with X mappings" in logs
2. Trigger manual scrape
3. Observe log lines showing cache lookups
4. If unmapped market found: verify it appears in unmapped_market_log
  </verify>
  <done>
- Cache initialization logged at startup
- Scraping uses cache lookups (verified via logs)
- Unmapped markets correctly logged when cache misses
  </done>
</task>
</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds in web/
- [ ] Backend starts without errors
- [ ] MappingCache loads code+DB mappings at startup
- [ ] User mappings created via API are used during scraping
- [ ] Existing mappings visible on dashboard
- [ ] Edit flow works for user mappings
- [ ] Override flow works for code mappings
</verification>

<success_criteria>
- UAT-001: User mappings are applied during scraping (BLOCKER fixed)
- UAT-002: Existing mappings browsable and editable (BLOCKER fixed)
- UAT-003: Unmapped markets logged when cache misses (MAJOR fixed by UAT-001)
- Ready for re-verification with /gsd:verify-work 104
</success_criteria>

<output>
After completion, create `.planning/phases/104-mapping-editor/104-FIX-SUMMARY.md`
</output>
