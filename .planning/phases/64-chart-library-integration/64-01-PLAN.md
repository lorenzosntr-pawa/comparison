---
phase: 64-chart-library-integration
plan: 01
type: execute
---

<objective>
Add TypeScript types, API methods, hooks, and base chart components for historical odds/margin visualization.

Purpose: Enable visualization of price movements over time with reusable chart components that can be embedded in dialogs across Odds Comparison and Event Details pages.
Output: History types in api.ts, API methods in api.ts, useOddsHistory/useMarginHistory hooks, OddsLineChart and MarginLineChart components.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./64-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase context (freshness timestamps)
@.planning/phases/63-freshness-timestamps/63-01-SUMMARY.md

# History API implementation
@src/api/routes/history.py
@src/matching/schemas.py

# Frontend patterns to follow
@web/src/types/api.ts
@web/src/lib/api.ts
@web/src/features/matches/hooks/use-match-detail.ts

**Tech stack available:**
- recharts v3.6.0 (already installed)
- TanStack Query v5 with established hook patterns
- shadcn/ui components with Tailwind v4
- date-fns for date formatting

**Established patterns:**
- TypeScript interfaces in web/src/types/api.ts
- API methods as object properties in web/src/lib/api.ts
- Hooks use useQuery with queryKey, queryFn, enabled, staleTime, gcTime
- UI components use cn() for className merging, text-muted-foreground for secondary text

**API endpoints available:**
- GET /api/events/{event_id}/markets/{market_id}/history - full odds time-series (ASC)
- GET /api/events/{event_id}/markets/{market_id}/margin-history - margin-only time-series (ASC)

**Response formats:**
- OddsHistoryResponse: event_id, bookmaker_slug/name, market_id/name, line, history[] (captured_at, outcomes[], margin)
- MarginHistoryResponse: event_id, bookmaker_slug/name, market_id/name, line, history[] (captured_at, margin)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add history types and API methods</name>
  <files>web/src/types/api.ts, web/src/lib/api.ts</files>
  <action>
Add TypeScript interfaces matching the backend Pydantic schemas:

In web/src/types/api.ts, add at the end:
```typescript
// Historical data types for odds/margin visualization

export interface OddsHistoryPoint {
  captured_at: string
  outcomes: OutcomeOdds[]
  margin: number | null
}

export interface OddsHistoryResponse {
  event_id: number
  bookmaker_slug: string
  bookmaker_name: string
  market_id: string
  market_name: string
  line: number | null
  history: OddsHistoryPoint[]
}

export interface MarginHistoryPoint {
  captured_at: string
  margin: number | null
}

export interface MarginHistoryResponse {
  event_id: number
  bookmaker_slug: string
  bookmaker_name: string
  market_id: string
  market_name: string
  line: number | null
  history: MarginHistoryPoint[]
}
```

In web/src/lib/api.ts:
1. Import OddsHistoryResponse and MarginHistoryResponse from @/types/api
2. Add two new API methods:

```typescript
getOddsHistory: (params: {
  eventId: number
  marketId: string
  bookmakerSlug: string
  fromTime?: string
  toTime?: string
}) => {
  const searchParams = new URLSearchParams()
  searchParams.set('bookmaker_slug', params.bookmakerSlug)
  if (params.fromTime) searchParams.set('from_time', params.fromTime)
  if (params.toTime) searchParams.set('to_time', params.toTime)
  return fetchJson<OddsHistoryResponse>(
    `/events/${params.eventId}/markets/${encodeURIComponent(params.marketId)}/history?${searchParams}`
  )
},

getMarginHistory: (params: {
  eventId: number
  marketId: string
  bookmakerSlug: string
  fromTime?: string
  toTime?: string
}) => {
  const searchParams = new URLSearchParams()
  searchParams.set('bookmaker_slug', params.bookmakerSlug)
  if (params.fromTime) searchParams.set('from_time', params.fromTime)
  if (params.toTime) searchParams.set('to_time', params.toTime)
  return fetchJson<MarginHistoryResponse>(
    `/events/${params.eventId}/markets/${encodeURIComponent(params.marketId)}/margin-history?${searchParams}`
  )
},
```

Note: Use encodeURIComponent for market_id since it can contain special characters (e.g., "1x2", "over_under_2.5").
  </action>
  <verify>TypeScript compiles without errors: cd web && npx tsc --noEmit</verify>
  <done>6 new types added to api.ts, 2 new API methods added with proper URL encoding</done>
</task>

<task type="auto">
  <name>Task 2: Create history data hooks</name>
  <files>web/src/features/matches/hooks/use-odds-history.ts, web/src/features/matches/hooks/use-margin-history.ts, web/src/features/matches/hooks/index.ts</files>
  <action>
Create two new hooks following the existing use-match-detail.ts pattern.

Create web/src/features/matches/hooks/use-odds-history.ts:
```typescript
import { useQuery } from '@tanstack/react-query'
import { api } from '@/lib/api'

export interface UseOddsHistoryParams {
  eventId: number
  marketId: string
  bookmakerSlug: string
  fromTime?: string
  toTime?: string
  enabled?: boolean
}

export function useOddsHistory({
  eventId,
  marketId,
  bookmakerSlug,
  fromTime,
  toTime,
  enabled = true,
}: UseOddsHistoryParams) {
  return useQuery({
    queryKey: ['odds-history', eventId, marketId, bookmakerSlug, fromTime, toTime],
    queryFn: () => api.getOddsHistory({
      eventId,
      marketId,
      bookmakerSlug,
      fromTime,
      toTime,
    }),
    enabled: enabled && !!eventId && !!marketId && !!bookmakerSlug,
    staleTime: 60000, // 1 minute - historical data changes slowly
    gcTime: 300000, // 5 minutes
  })
}
```

Create web/src/features/matches/hooks/use-margin-history.ts:
```typescript
import { useQuery } from '@tanstack/react-query'
import { api } from '@/lib/api'

export interface UseMarginHistoryParams {
  eventId: number
  marketId: string
  bookmakerSlug: string
  fromTime?: string
  toTime?: string
  enabled?: boolean
}

export function useMarginHistory({
  eventId,
  marketId,
  bookmakerSlug,
  fromTime,
  toTime,
  enabled = true,
}: UseMarginHistoryParams) {
  return useQuery({
    queryKey: ['margin-history', eventId, marketId, bookmakerSlug, fromTime, toTime],
    queryFn: () => api.getMarginHistory({
      eventId,
      marketId,
      bookmakerSlug,
      fromTime,
      toTime,
    }),
    enabled: enabled && !!eventId && !!marketId && !!bookmakerSlug,
    staleTime: 60000, // 1 minute
    gcTime: 300000, // 5 minutes
  })
}
```

Update web/src/features/matches/hooks/index.ts to export the new hooks:
```typescript
export * from './use-odds-history'
export * from './use-margin-history'
```
  </action>
  <verify>TypeScript compiles: cd web && npx tsc --noEmit</verify>
  <done>useOddsHistory and useMarginHistory hooks created with proper query keys and caching</done>
</task>

<task type="auto">
  <name>Task 3: Create base chart components</name>
  <files>web/src/features/matches/components/odds-line-chart.tsx, web/src/features/matches/components/margin-line-chart.tsx, web/src/features/matches/components/index.ts</files>
  <action>
Create reusable chart components using recharts. These will be used in history dialogs in later phases.

Create web/src/features/matches/components/odds-line-chart.tsx:
```typescript
import { useMemo } from 'react'
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  Legend,
} from 'recharts'
import { format } from 'date-fns'
import type { OddsHistoryPoint } from '@/types/api'

// Color palette for outcome lines (up to 4 outcomes typical)
const OUTCOME_COLORS = [
  'hsl(var(--chart-1))', // Blue
  'hsl(var(--chart-2))', // Green
  'hsl(var(--chart-3))', // Orange
  'hsl(var(--chart-4))', // Purple
]

interface OddsLineChartProps {
  data: OddsHistoryPoint[]
  height?: number
  showMargin?: boolean
}

export function OddsLineChart({
  data,
  height = 300,
  showMargin = false,
}: OddsLineChartProps) {
  // Transform data for recharts - flatten outcomes into columns
  const chartData = useMemo(() => {
    if (!data.length) return []

    return data.map((point) => {
      const row: Record<string, number | string | null> = {
        time: point.captured_at,
        timeLabel: format(new Date(point.captured_at), 'HH:mm'),
        margin: point.margin,
      }
      // Add each outcome as a separate column
      point.outcomes.forEach((outcome) => {
        row[outcome.name] = outcome.odds
      })
      return row
    })
  }, [data])

  // Get unique outcome names from first data point
  const outcomeNames = useMemo(() => {
    if (!data.length || !data[0].outcomes.length) return []
    return data[0].outcomes.map((o) => o.name)
  }, [data])

  if (!data.length) {
    return (
      <div className="flex items-center justify-center h-[300px] text-muted-foreground">
        No historical data available
      </div>
    )
  }

  return (
    <ResponsiveContainer width="100%" height={height}>
      <LineChart data={chartData} margin={{ top: 5, right: 20, left: 10, bottom: 5 }}>
        <CartesianGrid strokeDasharray="3 3" className="stroke-muted" />
        <XAxis
          dataKey="timeLabel"
          tick={{ fontSize: 12 }}
          className="text-muted-foreground"
        />
        <YAxis
          domain={['auto', 'auto']}
          tick={{ fontSize: 12 }}
          className="text-muted-foreground"
          tickFormatter={(value) => value.toFixed(2)}
        />
        <Tooltip
          contentStyle={{
            backgroundColor: 'hsl(var(--popover))',
            border: '1px solid hsl(var(--border))',
            borderRadius: '6px',
          }}
          labelFormatter={(label, payload) => {
            if (payload?.[0]?.payload?.time) {
              return format(new Date(payload[0].payload.time), 'MMM d, HH:mm')
            }
            return label
          }}
          formatter={(value: number) => [value.toFixed(2), '']}
        />
        <Legend />
        {outcomeNames.map((name, index) => (
          <Line
            key={name}
            type="monotone"
            dataKey={name}
            stroke={OUTCOME_COLORS[index % OUTCOME_COLORS.length]}
            strokeWidth={2}
            dot={false}
            activeDot={{ r: 4 }}
          />
        ))}
        {showMargin && (
          <Line
            type="monotone"
            dataKey="margin"
            stroke="hsl(var(--chart-5))"
            strokeWidth={1}
            strokeDasharray="5 5"
            dot={false}
            name="Margin %"
          />
        )}
      </LineChart>
    </ResponsiveContainer>
  )
}
```

Create web/src/features/matches/components/margin-line-chart.tsx:
```typescript
import { useMemo } from 'react'
import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
  ReferenceLine,
} from 'recharts'
import { format } from 'date-fns'
import type { MarginHistoryPoint } from '@/types/api'

interface MarginLineChartProps {
  data: MarginHistoryPoint[]
  height?: number
  referenceValue?: number // Optional reference line (e.g., competitor margin)
  referenceLabel?: string
}

export function MarginLineChart({
  data,
  height = 200,
  referenceValue,
  referenceLabel,
}: MarginLineChartProps) {
  const chartData = useMemo(() => {
    return data.map((point) => ({
      time: point.captured_at,
      timeLabel: format(new Date(point.captured_at), 'HH:mm'),
      margin: point.margin,
    }))
  }, [data])

  if (!data.length) {
    return (
      <div className="flex items-center justify-center h-[200px] text-muted-foreground">
        No margin data available
      </div>
    )
  }

  return (
    <ResponsiveContainer width="100%" height={height}>
      <LineChart data={chartData} margin={{ top: 5, right: 20, left: 10, bottom: 5 }}>
        <CartesianGrid strokeDasharray="3 3" className="stroke-muted" />
        <XAxis
          dataKey="timeLabel"
          tick={{ fontSize: 12 }}
          className="text-muted-foreground"
        />
        <YAxis
          domain={['auto', 'auto']}
          tick={{ fontSize: 12 }}
          className="text-muted-foreground"
          tickFormatter={(value) => `${value.toFixed(1)}%`}
          width={50}
        />
        <Tooltip
          contentStyle={{
            backgroundColor: 'hsl(var(--popover))',
            border: '1px solid hsl(var(--border))',
            borderRadius: '6px',
          }}
          labelFormatter={(label, payload) => {
            if (payload?.[0]?.payload?.time) {
              return format(new Date(payload[0].payload.time), 'MMM d, HH:mm')
            }
            return label
          }}
          formatter={(value: number) => [`${value.toFixed(2)}%`, 'Margin']}
        />
        <Line
          type="monotone"
          dataKey="margin"
          stroke="hsl(var(--chart-1))"
          strokeWidth={2}
          dot={false}
          activeDot={{ r: 4 }}
        />
        {referenceValue !== undefined && (
          <ReferenceLine
            y={referenceValue}
            stroke="hsl(var(--destructive))"
            strokeDasharray="5 5"
            label={{
              value: referenceLabel || `${referenceValue.toFixed(1)}%`,
              position: 'right',
              fill: 'hsl(var(--destructive))',
              fontSize: 11,
            }}
          />
        )}
      </LineChart>
    </ResponsiveContainer>
  )
}
```

Update web/src/features/matches/components/index.ts to export the new components:
Add at the end of the existing exports:
```typescript
export * from './odds-line-chart'
export * from './margin-line-chart'
```

Note: The chart colors use CSS variables (--chart-1, etc.) from shadcn/ui theme. Verify these exist in the CSS; if not, use fallback hex colors like '#3b82f6' (blue), '#22c55e' (green), '#f97316' (orange), '#8b5cf6' (purple).
  </action>
  <verify>cd web && npx tsc --noEmit && npm run build (should complete without errors)</verify>
  <done>OddsLineChart and MarginLineChart components created with responsive sizing, proper Tailwind/shadcn theming, and configurable options</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `cd web && npx tsc --noEmit` passes without errors
- [ ] `cd web && npm run build` succeeds
- [ ] New types match backend Pydantic schemas (OddsHistoryResponse, MarginHistoryResponse)
- [ ] API methods properly encode market_id in URLs
- [ ] Hooks follow existing patterns (queryKey, enabled, staleTime)
- [ ] Chart components use ResponsiveContainer for proper sizing
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- TypeScript types match backend schemas exactly
- Hooks ready for use in history dialogs
- Chart components render properly with sample data
- No new lint warnings or type errors
</success_criteria>

<output>
After completion, create `.planning/phases/64-chart-library-integration/64-01-SUMMARY.md`:

# Phase 64 Plan 01: Chart Library Integration Summary

**[Substantive one-liner]**

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Decisions or "None"]

## Issues Encountered

[Issues or "None"]

## Next Phase Readiness

[Ready for Phase 65: History Dialog Component]
</output>
