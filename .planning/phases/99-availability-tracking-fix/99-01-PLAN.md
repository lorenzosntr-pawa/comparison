---
phase: 99-availability-tracking-fix
plan: 01
type: execute
---

<objective>
Complete v2.5 availability tracking by wiring detection results through to database persistence.

Purpose: The availability detection logic exists and works correctly, but the detected `unavailable_at` timestamps are logged and discarded rather than persisted. This fix ensures markets that become unavailable are tracked in the database.

Output: Markets that disappear from scrapes have their `unavailable_at` timestamp persisted to the database, and the API correctly reports availability status.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (v2.5 availability tracking)
@.planning/phases/87-investigation-schema-design/87-01-SUMMARY.md
@.planning/phases/88-backend-availability-tracking/88-01-SUMMARY.md
@.planning/phases/89-api-availability-endpoints/89-01-SUMMARY.md

# Key source files
@src/storage/write_queue.py
@src/storage/write_handler.py
@src/caching/availability_detection.py
@src/scraping/event_coordinator.py

**The Bug (identified via code exploration):**
1. ✅ Detection works - `detect_availability_changes()` in availability_detection.py correctly identifies markets that became unavailable
2. ❌ Detection results discarded - `_detect_and_log_availability_changes()` in event_coordinator.py only logs counts, throws away the CachedMarket objects
3. ❌ `MarketWriteData` missing field - The dataclass has no `unavailable_at` field
4. ❌ Write handler doesn't set it - `_build_market_odds()` never sets unavailable_at on ORM models
5. ❌ Database always NULL - All market_odds rows have unavailable_at = NULL

**Fix approach:**
- For NEW markets being inserted: Add `unavailable_at` field to MarketWriteData, pass it through to ORM
- For EXISTING markets that disappeared: Add new update path to mark them unavailable via WriteBatch

**Established patterns:**
- Availability extraction: `unavailable_at = getattr(market, 'unavailable_at', None); available = unavailable_at is None`
- Frozen dataclass DTOs for write queue
- UPDATE via WriteBatch (existing pattern for unchanged_betpawa_ids)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add unavailable_at to MarketWriteData and write handler</name>
  <files>src/storage/write_queue.py, src/storage/write_handler.py</files>
  <action>
1. In write_queue.py, add `unavailable_at: datetime | None = None` field to MarketWriteData dataclass (after market_groups)
   - Import datetime at top: `from datetime import datetime`
   - Field should have default None for backward compatibility

2. In write_handler.py, update _build_market_odds() to pass unavailable_at:
   ```python
   def _build_market_odds(mwd: MarketWriteData) -> MarketOdds:
       return MarketOdds(
           # ... existing fields ...
           unavailable_at=mwd.unavailable_at,  # ADD THIS
       )
   ```

3. Update _build_competitor_market_odds() similarly:
   ```python
   def _build_competitor_market_odds(mwd: MarketWriteData) -> CompetitorMarketOdds:
       return CompetitorMarketOdds(
           # ... existing fields ...
           unavailable_at=mwd.unavailable_at,  # ADD THIS
       )
   ```

This enables new market inserts to include availability status. Default None means existing code continues to work.
  </action>
  <verify>python -c "from src.storage.write_queue import MarketWriteData; m = MarketWriteData('id','name',None,None,None,None,{},None,None); print(f'unavailable_at={m.unavailable_at}')"</verify>
  <done>MarketWriteData has unavailable_at field, write handler passes it to ORM models</done>
</task>

<task type="auto">
  <name>Task 2: Add availability update path to WriteBatch</name>
  <files>src/storage/write_queue.py, src/storage/write_handler.py</files>
  <action>
1. In write_queue.py, create UnavailableMarketUpdate dataclass BEFORE WriteBatch:
   ```python
   @dataclass(frozen=True)
   class UnavailableMarketUpdate:
       """Track a market that became unavailable - needs UPDATE on existing row."""
       snapshot_id: int
       betpawa_market_id: str
       unavailable_at: datetime
   ```

2. Add two new fields to WriteBatch dataclass:
   ```python
   @dataclass(frozen=True)
   class WriteBatch:
       # ... existing fields ...
       unavailable_betpawa: tuple[UnavailableMarketUpdate, ...] = ()  # ADD
       unavailable_competitor: tuple[UnavailableMarketUpdate, ...] = ()  # ADD
   ```
   Use default empty tuple for backward compatibility.

3. In write_handler.py, import the new type:
   ```python
   from src.storage.write_queue import (
       # ... existing imports ...
       UnavailableMarketUpdate,
   )
   ```

4. In handle_write_batch(), add UPDATE logic after the unchanged timestamp updates (before commit):
   ```python
   # ----------------------------------------------------------
   # 5. UPDATE unavailable BetPawa markets
   # ----------------------------------------------------------
   unavailable_bp_count = 0
   for umu in batch.unavailable_betpawa:
       await db.execute(
           update(MarketOdds)
           .where(
               MarketOdds.snapshot_id == umu.snapshot_id,
               MarketOdds.betpawa_market_id == umu.betpawa_market_id,
           )
           .values(unavailable_at=umu.unavailable_at)
       )
       unavailable_bp_count += 1

   # ----------------------------------------------------------
   # 6. UPDATE unavailable competitor markets
   # ----------------------------------------------------------
   unavailable_comp_count = 0
   for umu in batch.unavailable_competitor:
       await db.execute(
           update(CompetitorMarketOdds)
           .where(
               CompetitorMarketOdds.snapshot_id == umu.snapshot_id,
               CompetitorMarketOdds.betpawa_market_id == umu.betpawa_market_id,
           )
           .values(unavailable_at=umu.unavailable_at)
       )
       unavailable_comp_count += 1
   ```

5. Add counts to stats dict returned by handle_write_batch:
   ```python
   stats = {
       # ... existing stats ...
       "unavailable_bp": unavailable_bp_count,
       "unavailable_comp": unavailable_comp_count,
   }
   ```

6. Update the enqueue log in AsyncWriteQueue.enqueue() to include new fields:
   Add `unavailable_bp=len(batch.unavailable_betpawa), unavailable_comp=len(batch.unavailable_competitor)` to the debug log.
  </action>
  <verify>python -c "from src.storage.write_queue import WriteBatch, UnavailableMarketUpdate; print('UnavailableMarketUpdate imported'); wb = WriteBatch((),(),(),(),None,0); print(f'unavailable_betpawa={wb.unavailable_betpawa}')"</verify>
  <done>WriteBatch has unavailable_betpawa/unavailable_competitor fields, write_handler UPDATEs them</done>
</task>

<task type="auto">
  <name>Task 3: Wire detection results into write batch</name>
  <files>src/scraping/event_coordinator.py</files>
  <action>
1. Import UnavailableMarketUpdate at top of event_coordinator.py:
   ```python
   from src.storage.write_queue import (
       # ... existing imports ...
       UnavailableMarketUpdate,
   )
   ```

2. Modify _detect_and_log_availability_changes() to RETURN the unavailable markets instead of just counting:
   - Change return type to `tuple[list[UnavailableMarketUpdate], list[UnavailableMarketUpdate]]` (betpawa, competitor)
   - Instead of just incrementing counters, build UnavailableMarketUpdate objects
   - The CachedMarket from detection has the snapshot_id available via its parent CachedSnapshot

   Find the section that processes detection results and modify it:
   ```python
   # Build update objects instead of just counting
   unavailable_bp_updates: list[UnavailableMarketUpdate] = []
   unavailable_comp_updates: list[UnavailableMarketUpdate] = []

   # For each became_unavailable CachedMarket, create an update:
   # Note: Need to extract snapshot_id from the cached snapshot context
   for market in became_unavailable:
       unavailable_bp_updates.append(UnavailableMarketUpdate(
           snapshot_id=snapshot_id,  # from the cached snapshot
           betpawa_market_id=market.betpawa_market_id,
           unavailable_at=market.unavailable_at,
       ))
   ```

3. In store_batch_results() async path, capture the return value from detection:
   ```python
   unavailable_bp, unavailable_comp = self._detect_and_log_availability_changes(...)
   ```

4. Pass unavailable markets when creating WriteBatch:
   ```python
   write_batch = WriteBatch(
       # ... existing fields ...
       unavailable_betpawa=tuple(unavailable_bp),
       unavailable_competitor=tuple(unavailable_comp),
   )
   ```

5. Similarly update _detect_and_log_availability_changes_sync() for the sync fallback path, and update _store_batch_results_sync() to pass the unavailable markets.

**Key insight:** The detection function already has access to the cached snapshots (which have snapshot_id). Extract the snapshot_id when building UnavailableMarketUpdate objects. The CachedSnapshot is passed to detect_availability_changes(), so we know which snapshot each market belongs to.
  </action>
  <verify>Run a test scrape and check logs for "unavailable_bp" stats in write_batch_processed. Also query: SELECT COUNT(*) FROM market_odds WHERE unavailable_at IS NOT NULL;</verify>
  <done>Detection results flow through to WriteBatch, unavailable_at persists to database</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `python -c "from src.storage.write_queue import MarketWriteData, UnavailableMarketUpdate, WriteBatch"` succeeds
- [ ] pytest passes (run existing tests to ensure no regressions)
- [ ] Start the application and trigger a scrape cycle
- [ ] Check logs for "unavailable_bp" and "unavailable_comp" counts in write_batch_processed
- [ ] Query database: `SELECT COUNT(*) FROM market_odds WHERE unavailable_at IS NOT NULL;` shows non-zero after markets disappear
- [ ] API returns correct `available: false` for markets that disappeared
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript/Python errors
- Detection results persist to database via write queue
- API correctly reports availability status for disappeared markets
</success_criteria>

<output>
After completion, create `.planning/phases/99-availability-tracking-fix/99-01-SUMMARY.md`:

# Phase 99 Plan 01: Availability Tracking Fix Summary

**[Substantive one-liner about what shipped]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 99 complete, v2.7 milestone ready to ship.
</output>
