---
phase: 109-realtime-updates
plan: 01
type: execute
---

<objective>
Add WebSocket infrastructure for real-time risk alert broadcasting.

Purpose: Enable instant alert delivery to connected clients when new alerts are detected during scraping.
Output: Backend broadcasts alert notifications via WebSocket when alerts are persisted.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/108-risk-page/108-01-SUMMARY.md

# Existing WebSocket infrastructure:
@src/api/websocket/manager.py
@src/api/websocket/messages.py
@src/api/websocket/bridge.py
@src/storage/write_queue.py

**Tech stack available:** WebSocket with ConnectionManager, topic-based pub/sub, odds_update broadcast pattern
**Established patterns:**
- Topic-based broadcasting via ConnectionManager.broadcast(message, topic)
- Message envelope: {type, timestamp, data} via _envelope() helper
- Bridge pattern: callbacks or async tasks for broadcasting
- AsyncWriteQueue processes WriteBatch and returns stats

**Constraining decisions:**
- Alerts are persisted in write_handler.py after commit
- AsyncWriteQueue._process_with_retry() calls handle_write_batch()
- Stats dict includes alerts_inserted count
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add risk_alerts topic and message builder</name>
  <files>src/api/websocket/manager.py, src/api/websocket/messages.py</files>
  <action>
1. In manager.py: Add "risk_alerts" to the TOPICS set (line ~15)

2. In messages.py: Add risk_alert_message() function:
```python
def risk_alert_message(
    alert_count: int,
    event_ids: list[int],
    severities: list[str],
) -> dict:
    """Build a risk_alert notification message.

    Lightweight notification â€” frontend fetches full data from API.

    Args:
        alert_count: Number of new alerts detected.
        event_ids: List of event IDs with new alerts.
        severities: List of severity levels present (warning, elevated, critical).

    Returns:
        Typed message dict with type "risk_alert".
    """
    return _envelope(
        "risk_alert",
        {
            "alert_count": alert_count,
            "event_ids": event_ids,
            "severities": severities,
        },
    )
```

Keep message lightweight - frontend will query API for full alert data.
  </action>
  <verify>grep -q "risk_alerts" src/api/websocket/manager.py && grep -q "risk_alert_message" src/api/websocket/messages.py</verify>
  <done>TOPICS includes "risk_alerts", risk_alert_message() function exists with proper signature</done>
</task>

<task type="auto">
  <name>Task 2: Broadcast alerts after persistence</name>
  <files>src/storage/write_queue.py, src/api/app.py</files>
  <action>
1. In write_queue.py:
   - Add ws_manager parameter to AsyncWriteQueue.__init__ (optional, defaults to None):
     ```python
     def __init__(self, session_factory, maxsize: int = 50, ws_manager=None):
         ...
         self._ws_manager = ws_manager
     ```

   - In _process_with_retry(), after successful handle_write_batch() call, broadcast if alerts were inserted:
     ```python
     if stats.get("alerts_inserted", 0) > 0 and self._ws_manager:
         from src.api.websocket.messages import risk_alert_message
         # Extract event_ids and severities from batch.alerts
         event_ids = list({a.event_id for a in batch.alerts})
         severities = list({a.severity for a in batch.alerts})
         msg = risk_alert_message(
             alert_count=stats["alerts_inserted"],
             event_ids=event_ids,
             severities=severities,
         )
         try:
             loop = asyncio.get_running_loop()
             loop.create_task(self._ws_manager.broadcast(msg, topic="risk_alerts"))
         except RuntimeError:
             pass  # No running loop
     ```

   - Add asyncio import at top if not present

2. In app.py lifespan:
   - Find where AsyncWriteQueue is created (after cache warmup)
   - Pass ws_manager to constructor:
     ```python
     app.state.write_queue = AsyncWriteQueue(
         session_factory,
         maxsize=50,
         ws_manager=app.state.ws_manager,
     )
     ```

Note: The ws_manager is created BEFORE the write_queue in lifespan, so it will be available.
  </action>
  <verify>grep -q "ws_manager" src/storage/write_queue.py && python -c "from src.storage.write_queue import AsyncWriteQueue; print('OK')"</verify>
  <done>AsyncWriteQueue accepts ws_manager, broadcasts risk_alert messages when alerts_inserted > 0</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `grep "risk_alerts" src/api/websocket/manager.py` shows topic in TOPICS set
- [ ] `grep "risk_alert_message" src/api/websocket/messages.py` shows function definition
- [ ] `grep "ws_manager" src/storage/write_queue.py` shows parameter and broadcast logic
- [ ] `python -c "from src.storage.write_queue import AsyncWriteQueue; from src.api.websocket.messages import risk_alert_message; print('imports OK')"`
</verification>

<success_criteria>

- TOPICS set includes "risk_alerts"
- risk_alert_message() function creates proper envelope
- AsyncWriteQueue broadcasts when alerts are persisted
- No import errors or runtime issues
</success_criteria>

<output>
After completion, create `.planning/phases/109-realtime-updates/109-01-SUMMARY.md`
</output>
