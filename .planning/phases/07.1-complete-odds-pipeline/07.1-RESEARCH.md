# Phase 7.1: Complete Odds Pipeline - Research

**Researched:** 2026-01-21
**Domain:** Internal codebase analysis (not external ecosystem)
**Confidence:** HIGH

<research_summary>
## Summary

Comprehensive codebase analysis to understand why BetPawa odds aren't being stored and verify market mapping accuracy.

**Key Findings:**

1. **BetPawa odds NOT stored**: The scraping orchestrator ([orchestrator.py](src/scraping/orchestrator.py):858-871) only calls `EventMatchingService.process_scraped_events()` for BetPawa, which stores event metadata but NOT OddsSnapshot records. SportyBet and Bet9ja correctly create OddsSnapshots with MarketOdds.

2. **Market mapping parity**: Python has 108 markets, TypeScript has 109. One market is missing.

3. **No BetPawa mapper needed**: BetPawa IS the canonical format - its market IDs and outcome names are already the reference standard. Markets should be stored directly without transformation.

4. **Pattern exists**: The SportyBet and Bet9ja implementations show exactly how to create OddsSnapshot + MarketOdds records.

**Primary recommendation:** Add OddsSnapshot/MarketOdds creation to BetPawa scraper following the SportyBet pattern, add missing market mapping, verify UI displays stored odds.
</research_summary>

<root_cause_analysis>
## Root Cause: BetPawa Odds Not Stored

### The Problem
Looking at `_store_events` in [orchestrator.py](src/scraping/orchestrator.py):751-871:

**SportyBet (lines 779-815):**
```python
if platform == Platform.SPORTYBET:
    # Creates EventBookmaker link
    await service.upsert_event_bookmaker(...)

    # Creates OddsSnapshot with raw response ✓
    snapshot = OddsSnapshot(
        event_id=event.id,
        bookmaker_id=bookmaker_id,
        raw_response=event_data.get("raw_data"),
    )
    db.add(snapshot)

    # Parses markets and creates MarketOdds ✓
    market_odds = self._parse_sportybet_markets(raw_data)
    for mo in market_odds:
        mo.snapshot_id = snapshot.id
        db.add(mo)
```

**Bet9ja (lines 817-858):**
```python
if platform == Platform.BET9JA:
    # Uses EventMatchingService for event storage
    result = await service.process_scraped_events(...)

    # Creates OddsSnapshot with raw responses ✓
    snapshot = OddsSnapshot(...)
    db.add(snapshot)

    # Parses markets and creates MarketOdds ✓
    market_odds = self._parse_bet9ja_markets(event_data["raw_data"])
```

**BetPawa (lines 860-871):**
```python
# ONLY calls process_scraped_events - NO OddsSnapshot creation!
result = await service.process_scraped_events(
    db=db,
    platform=platform,
    bookmaker_id=bookmaker_id,
    events=events,
)
# ❌ No OddsSnapshot creation
# ❌ No MarketOdds creation
```

### Why It Happened
BetPawa was implemented as the "primary" platform for event discovery, focused on getting event metadata (SportRadar IDs, teams, kickoff times) into the database. Odds storage was likely planned for later and never added.

### What's Missing
1. BetPawa scraper needs to store `raw_data` in event dicts (currently doesn't)
2. `_store_events` needs OddsSnapshot creation block for BetPawa
3. Need `_parse_betpawa_markets()` method to convert raw response to MarketOdds
</root_cause_analysis>

<mapping_verification>
## Market Mapping Verification

### Mapping Count
| Source | Markets |
|--------|---------|
| TypeScript (mapping_markets/src/mappings/market-ids.ts) | 109 |
| Python (src/market_mapping/mappings/market_ids.py) | 108 |
| **Difference** | 1 missing |

### Missing Market Identification
Need to diff canonical_ids between files to find the missing market. Based on manual review, both files end with the same final market (`double_chance_btts_2h`).

### Outcome Mapping Accuracy
Spot-checked first 10 markets - all match exactly:
- `1x2_ft`: ✓ betpawa_id="3743", outcomes match
- `double_chance_ft`: ✓ betpawa_id="4693", outcomes match
- `btts_ft`: ✓ betpawa_id="3795", outcomes match
- `over_under_ft`: ✓ betpawa_id="5000", outcomes match
- etc.

### Recommendation
Run automated diff to find the missing market:
```bash
# Extract canonical IDs from TypeScript
grep 'canonicalId:' mapping_markets/src/mappings/market-ids.ts | sort > ts_ids.txt
# Extract from Python
grep 'canonical_id=' src/market_mapping/mappings/market_ids.py | sort > py_ids.txt
# Diff
diff ts_ids.txt py_ids.txt
```
</mapping_verification>

<betpawa_data_structure>
## BetPawa Data Structure

### Event API Response
BetPawa's `/api/sportsbook/v3/events/{id}` returns:
```json
{
  "id": "32299257",
  "name": "Manchester United - Manchester City",
  "startTime": "2026-01-21T15:00:00Z",
  "widgets": [{"type": "SPORTRADAR", "id": "sr:match:12345"}],
  "participants": [
    {"id": "1", "name": "Manchester United", "position": 1},
    {"id": "2", "name": "Manchester City", "position": 2}
  ],
  "markets": [
    {
      "marketType": {
        "id": "3743",      // <- This IS the betpawa_market_id
        "name": "1X2 - FT",
        "displayName": "1X2 | Full Time"
      },
      "row": [
        {
          "id": "row123",
          "handicap": null,
          "formattedHandicap": null,
          "prices": [
            {"name": "1", "price": 2.10, "handicap": null},
            {"name": "X", "price": 3.40, "handicap": null},
            {"name": "2", "price": 3.50, "handicap": null}
          ]
        }
      ]
    }
  ]
}
```

### Key Insight: No Mapping Needed
BetPawa markets are already in canonical format:
- `marketType.id` = `betpawa_market_id` for MarketOdds
- `marketType.displayName` = `betpawa_market_name`
- `prices[].name` = outcome names (already correct)
- `prices[].price` = decimal odds
- `row[].formattedHandicap` = line for over/under, handicap markets

### Pydantic Models Available
[src/market_mapping/types/betpawa.py](src/market_mapping/types/betpawa.py) has:
- `BetpawaEvent` - full event response
- `BetpawaMarket` - market with rows and prices
- `BetpawaRow` - row with handicap and prices
- `BetpawaPrice` - individual outcome with odds

These can be used to parse and validate the raw response.
</betpawa_data_structure>

<implementation_pattern>
## Implementation Pattern

### Pattern from SportyBet
```python
def _parse_sportybet_markets(self, raw_data: dict) -> list[MarketOdds]:
    market_odds_list = []
    markets = raw_data.get("markets", [])

    for market_data in markets:
        try:
            # Parse into Pydantic model
            sportybet_market = SportybetMarket.model_validate(market_data)

            # Map to Betpawa format (different API structure)
            mapped = map_sportybet_to_betpawa(sportybet_market)

            # Convert to MarketOdds
            outcomes = [...]
            market_odds = MarketOdds(
                betpawa_market_id=mapped.betpawa_market_id,
                betpawa_market_name=mapped.betpawa_market_name,
                line=mapped.line,
                outcomes=outcomes,
            )
            market_odds_list.append(market_odds)
        except MappingError:
            # Skip unmappable markets
            pass

    return market_odds_list
```

### New Pattern for BetPawa
BetPawa doesn't need mapping - direct extraction:
```python
def _parse_betpawa_markets(self, raw_data: dict) -> list[MarketOdds]:
    market_odds_list = []
    markets = raw_data.get("markets", [])

    for market_data in markets:
        market_type = market_data.get("marketType", {})
        market_id = market_type.get("id")

        if not market_id:
            continue

        for row in market_data.get("row", []):
            prices = row.get("prices", [])
            line = row.get("formattedHandicap")

            outcomes = [
                {
                    "name": p.get("name"),
                    "odds": p.get("price"),
                    "is_active": not p.get("suspended", False),
                }
                for p in prices
            ]

            market_odds = MarketOdds(
                betpawa_market_id=market_id,
                betpawa_market_name=market_type.get("displayName"),
                line=line,
                outcomes=outcomes,
            )
            market_odds_list.append(market_odds)

    return market_odds_list
```
</implementation_pattern>

<ui_verification>
## UI Display Verification

### Current UI Components
From Phase 7 work:
- [MatchList](web/src/features/matches/components/match-list.tsx) - displays core 3 markets
- [OddsCell](web/src/features/matches/components/odds-cell.tsx) - color-coded odds display
- [MarketComparisonGrid](web/src/features/matches/components/market-comparison-grid.tsx) - side-by-side comparison

### API Endpoint
[/api/events](src/api/routes/events.py) returns events with inline_odds:
```python
# Subquery for latest snapshot per (event_id, bookmaker_id)
latest_subquery = (
    select(
        OddsSnapshot.event_id,
        OddsSnapshot.bookmaker_id,
        func.max(OddsSnapshot.id).label("max_id")
    )
    .group_by(OddsSnapshot.event_id, OddsSnapshot.bookmaker_id)
    .subquery()
)
```

### Issue
If no OddsSnapshot exists for BetPawa, the inline_odds will be empty for that bookmaker. The UI correctly handles missing data (shows dash), but the whole point is to HAVE the data.

### Verification Steps After Fix
1. Trigger scrape via `/api/scrape`
2. Check database: `SELECT COUNT(*) FROM odds_snapshot WHERE bookmaker_id = (SELECT id FROM bookmaker WHERE slug = 'betpawa')`
3. Check API response: `/api/events` should include BetPawa in inline_odds
4. Check UI: Match list should show BetPawa odds in green/red color coding
</ui_verification>

<fix_checklist>
## Fix Checklist

### 1. BetPawa Odds Storage
- [ ] Modify `_scrape_betpawa_competition()` to fetch full event data with markets (currently uses list endpoint)
- [ ] Store `raw_data` in event dict returned from scraper
- [ ] Add `_parse_betpawa_markets()` method
- [ ] Add OddsSnapshot creation in `_store_events()` for BetPawa platform

### 2. Market Mapping Audit
- [ ] Run diff script to find missing market
- [ ] Add missing market to Python mappings
- [ ] Verify lookup functions work for new market

### 3. UI Verification
- [ ] Confirm events API returns BetPawa odds
- [ ] Confirm match list displays BetPawa column
- [ ] Confirm color coding works (green = BetPawa better)

### 4. Integration Test
- [ ] Manual scrape of small competition
- [ ] Verify all 3 bookmakers have odds in database
- [ ] Verify UI displays all 3 side-by-side
</fix_checklist>

<sources>
## Sources

### Primary (HIGH confidence)
- [src/scraping/orchestrator.py](src/scraping/orchestrator.py) - analyzed _store_events method
- [src/scraping/clients/betpawa.py](src/scraping/clients/betpawa.py) - analyzed API client
- [mapping_markets/src/mappings/market-ids.ts](mapping_markets/src/mappings/market-ids.ts) - TypeScript source of truth
- [src/market_mapping/mappings/market_ids.py](src/market_mapping/mappings/market_ids.py) - Python port
- [src/market_mapping/types/betpawa.py](src/market_mapping/types/betpawa.py) - BetPawa Pydantic models

### Internal Code Analysis
All findings verified by direct code inspection - no external research needed.
</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: Python/FastAPI/SQLAlchemy (existing codebase)
- Ecosystem: Internal market mapping and scraping infrastructure
- Patterns: OddsSnapshot/MarketOdds storage patterns
- Pitfalls: Missing odds storage, mapping drift

**Confidence breakdown:**
- Root cause: HIGH - direct code inspection shows missing OddsSnapshot creation
- Mapping count: HIGH - grep counts verified
- Fix pattern: HIGH - existing SportyBet/Bet9ja implementations to follow
- UI impact: HIGH - API query pattern understood

**Research date:** 2026-01-21
**Valid until:** N/A (internal code analysis, not external ecosystem)
</metadata>

---

*Phase: 07.1-complete-odds-pipeline*
*Research completed: 2026-01-21*
*Ready for planning: yes*
