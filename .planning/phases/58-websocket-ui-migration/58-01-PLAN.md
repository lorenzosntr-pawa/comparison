---
phase: 58-websocket-ui-migration
plan: 01
type: execute
---

<objective>
Create React hooks for WebSocket communication with the backend.

Purpose: Establish reusable WebSocket infrastructure that dashboard pages can use for real-time updates.
Output: Core `useWebSocket` hook and topic-specific `useWebSocketScrapeProgress` hook ready for UI integration.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 57 established WebSocket infrastructure:
@.planning/phases/57-websocket-infrastructure/57-01-SUMMARY.md
@.planning/phases/57-websocket-infrastructure/57-02-SUMMARY.md

# Backend WebSocket implementation:
@src/api/websocket/messages.py
@src/api/routes/ws.py

# Current SSE hooks for reference:
@web/src/features/scrape-runs/hooks/use-scrape-progress.ts
@web/src/features/dashboard/hooks/use-observe-scrape.ts

**Tech stack available:** React 19, TanStack Query v5, TypeScript 5
**Established patterns:**
- WebSocket endpoint at /api/ws with query param topic selection
- Message envelope: {type: str, timestamp: str, data: dict}
- Ping/pong for keepalive, dynamic subscribe/unsubscribe
- scrape_progress message data matches SSE ScrapeProgress shape
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create core useWebSocket hook</name>
  <files>web/src/hooks/use-websocket.ts</files>
  <action>
Create a reusable WebSocket hook with:

1. **Connection management:**
   - Connect to `/api/ws` with optional topics query param
   - Handle WebSocket open/close/error lifecycle
   - Track connection state: connecting | connected | disconnected | error

2. **Auto-reconnect with exponential backoff:**
   - On disconnect/error, attempt reconnect after delay
   - Delays: 1s, 2s, 4s, 8s, max 30s
   - Reset delay on successful connection
   - Max retries: 10 (then give up and stay disconnected)

3. **Ping/pong keepalive:**
   - Send ping every 30 seconds when connected
   - If no pong received within 5 seconds, force reconnect
   - Clear ping interval on disconnect

4. **Message handling:**
   - Accept onMessage callback for typed messages
   - Parse JSON, extract type/timestamp/data envelope
   - Handle connection_ack message (log subscribed topics)
   - Handle pong internally (don't forward to onMessage)
   - Handle error messages (log and optionally callback)

5. **Cleanup:**
   - Close WebSocket on unmount
   - Clear all timers (ping, reconnect)

Export types:
- WebSocketState: 'connecting' | 'connected' | 'disconnected' | 'error'
- WebSocketMessage<T>: { type: string; timestamp: string; data: T }
- UseWebSocketOptions: { topics?: string[]; onMessage?: (msg) => void; enabled?: boolean }
- UseWebSocketReturn: { state: WebSocketState; send: (msg) => void }

Use refs for WebSocket instance and timers to avoid effect dependencies.
Use useCallback for stable send function.
Use enabled option (default true) to conditionally connect.
  </action>
  <verify>Import hook in a test component, verify it connects to /api/ws and logs connection_ack</verify>
  <done>Hook connects, tracks state, auto-reconnects on disconnect, handles ping/pong</done>
</task>

<task type="auto">
  <name>Task 2: Create useWebSocketScrapeProgress hook</name>
  <files>web/src/hooks/use-websocket-scrape-progress.ts, web/src/hooks/index.ts</files>
  <action>
Create a specialized hook that wraps useWebSocket for scrape progress:

1. **Subscribe to scrape_progress topic:**
   - Connect with topics=["scrape_progress"]
   - Only connect when enabled (pass through to useWebSocket)

2. **State management (match existing SSE hook interface):**
   - isConnected: boolean
   - currentProgress: ScrapeProgressEvent | null
   - platformProgress: Map<string, PlatformProgress>
   - overallPhase: string
   - error: string | null

3. **Message handling:**
   - On scrape_progress message, extract data field
   - Update currentProgress with message.data
   - Update platformProgress map for platform-specific events
   - Track overall phase from progress events
   - On completed/failed, keep last state (don't reset)

4. **Types (reuse from SSE hooks):**
   - Import ScrapeProgressEvent shape from existing hooks
   - Export same interface as useScrapeProgress for easy migration

5. **Query invalidation integration:**
   - Accept queryClient from options (optional)
   - On completed/failed phase, invalidate scheduler-history and events queries
   - Match existing SSE hook behavior for drop-in replacement

Create web/src/hooks/index.ts exporting both hooks.

AVOID: Creating a new reducer - use useState for simplicity since WebSocket is already handling connection state. Keep the interface compatible with existing SSE hooks so components can switch with minimal changes.
  </action>
  <verify>npm run build succeeds, hook types match existing SSE hook interface</verify>
  <done>Hook subscribes to scrape_progress, provides same interface as SSE hooks, invalidates queries on completion</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` in web/ succeeds without TypeScript errors
- [ ] `npm run lint` passes
- [ ] useWebSocket connects to /api/ws and handles lifecycle
- [ ] useWebSocketScrapeProgress provides same interface as useScrapeProgress
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- WebSocket hooks ready for UI integration in 58-02
</success_criteria>

<output>
After completion, create `.planning/phases/58-websocket-ui-migration/58-01-SUMMARY.md`
</output>
