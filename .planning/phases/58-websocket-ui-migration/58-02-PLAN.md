---
phase: 58-websocket-ui-migration
plan: 02
type: execute
---

<objective>
Migrate dashboard and scrape-runs detail pages to use WebSocket for real-time progress, with SSE fallback.

Purpose: Replace SSE polling with persistent WebSocket connection for lower latency and reduced server load.
Output: Both dashboard and detail pages use WebSocket by default, fall back to SSE if WebSocket fails.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plan output:
@.planning/phases/58-websocket-ui-migration/58-01-SUMMARY.md

# WebSocket hooks created in 58-01:
@web/src/hooks/use-websocket.ts
@web/src/hooks/use-websocket-scrape-progress.ts

# Current SSE hooks to migrate:
@web/src/features/dashboard/hooks/use-observe-scrape.ts
@web/src/features/scrape-runs/hooks/use-scrape-progress.ts

# Components using these hooks:
@web/src/features/dashboard/components/recent-runs.tsx
@web/src/features/scrape-runs/detail.tsx

**Key constraint:** SSE endpoints remain unchanged — WebSocket runs alongside SSE, not replacing it on the backend.
**Fallback pattern:** Try WebSocket first. If WebSocket fails (3 consecutive reconnect failures), fall back to SSE polling.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate dashboard hooks to WebSocket with SSE fallback</name>
  <files>web/src/features/dashboard/hooks/use-observe-scrape.ts</files>
  <action>
Update useActiveScrapesObserver to prefer WebSocket:

1. **Primary: WebSocket via useWebSocketScrapeProgress:**
   - Import useWebSocketScrapeProgress from @/hooks
   - Connect when checking for active scrapes or when activeScrapeId is found
   - Use WebSocket progress state as primary source

2. **Fallback: SSE when WebSocket fails:**
   - Track wsFailCount state (increment on useWebSocket error/disconnected)
   - If wsFailCount >= 3, set useWebSocketEnabled = false
   - When WebSocket disabled, fall back to existing SSE implementation
   - Log fallback event for observability

3. **Integration:**
   - Keep existing useObserveScrape as SSE fallback
   - Combine states: prefer WebSocket state when connected, SSE when not
   - Return combined progress state to components

4. **Cleanup on unmount:**
   - WebSocket hook handles its own cleanup
   - SSE cleanup already implemented

The hook should be transparent to consumers - same return type regardless of transport.

AVOID: Removing SSE code entirely. Keep it as the fallback path. The goal is "run alongside SSE initially" per roadmap.
  </action>
  <verify>Hook connects via WebSocket when app starts, shows console log for connection_ack</verify>
  <done>Dashboard observes scrapes via WebSocket, falls back to SSE after 3 failures</done>
</task>

<task type="auto">
  <name>Task 2: Migrate scrape-runs detail hooks to WebSocket with SSE fallback</name>
  <files>web/src/features/scrape-runs/hooks/use-scrape-progress.ts</files>
  <action>
Update useScrapeProgress to prefer WebSocket:

1. **Primary: WebSocket when run is active:**
   - Import useWebSocketScrapeProgress from @/hooks
   - Enable WebSocket when isRunning is true
   - Use WebSocket state (currentProgress, platformProgress, overallPhase)

2. **Fallback: SSE when WebSocket fails:**
   - Track consecutive WebSocket failures
   - After 3 failures, disable WebSocket and use SSE
   - SSE connects to /api/scrape/runs/{runId}/progress (run-specific endpoint)

3. **State merging:**
   - When WebSocket connected, use WebSocket state
   - When WebSocket disconnected/failed, use SSE state
   - isConnected = wsConnected || sseConnected
   - currentProgress = wsProgress ?? sseProgress

4. **Query invalidation:**
   - Both transports trigger query invalidation on completed/failed
   - Avoid double invalidation (check phase before invalidating)

Keep existing SSE implementation intact but secondary. WebSocket provides global scrape_progress, while SSE is run-specific — both work for observing a specific run since there's typically only one active scrape.

AVOID: Breaking the onComplete callback pattern. Ensure it still fires on scrape completion.
  </action>
  <verify>Detail page shows WebSocket connection indicator, progress updates flow in real-time</verify>
  <done>Detail page uses WebSocket for progress, SSE fallback works if WebSocket fails</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>WebSocket-based real-time progress on dashboard and detail pages</what-built>
  <how-to-verify>
    1. Run: `npm run dev` in web/
    2. Run: `poetry run python -m src.api.main` in root
    3. Open: http://localhost:5173
    4. Dashboard test:
       - Check browser DevTools Network tab, filter by "WS"
       - Verify WebSocket connection to /api/ws established
       - Click "Start New Scrape" button
       - Confirm progress updates appear in real-time via WebSocket
       - Verify no SSE requests to /api/scrape/stream during normal operation
    5. Detail page test:
       - Navigate to Scrape Runs → click any completed run
       - Start a new scrape from dashboard
       - Go back to /scrape-runs, click the running scrape
       - Verify live progress displays via WebSocket
       - Check "Connected" indicator shows WebSocket status
    6. Fallback test (optional):
       - Stop backend while connected
       - Verify reconnection attempts in console
       - After 3 failures, verify SSE fallback activates
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` in web/ succeeds
- [ ] `npm run lint` passes
- [ ] WebSocket connection established on page load
- [ ] Progress updates flow via WebSocket during scrape
- [ ] SSE fallback activates after WebSocket failures
- [ ] No console errors during normal operation
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Human verification approved
- Dashboard and detail pages use WebSocket with SSE fallback
- Phase 58 complete, ready for Phase 59 (SSE removal)
</success_criteria>

<output>
After completion, create `.planning/phases/58-websocket-ui-migration/58-02-SUMMARY.md`
</output>
