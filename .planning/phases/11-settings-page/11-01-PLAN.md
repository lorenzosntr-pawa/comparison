---
phase: 11-settings-page
plan: 01
type: execute
---

<objective>
Create backend infrastructure for scraping configuration settings.

Purpose: Enable runtime control of scheduler interval and platform selection without code changes or server restarts.
Output: Settings database model, migration, and API endpoints for configuration management.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-settings-page/11-CONTEXT.md

# Key source files:
@src/scheduling/scheduler.py
@src/scheduling/jobs.py
@src/api/routes/scheduler.py
@src/api/schemas/scheduler.py
@src/db/models/__init__.py

**Tech stack available:**
- APScheduler AsyncIOScheduler with IntervalTrigger
- SQLAlchemy 2.0 async with Mapped[] columns
- FastAPI with Pydantic v2 schemas
- Alembic for migrations

**Established patterns:**
- Schemas package: src/api/schemas/ with __init__.py re-exporting all models
- ConfigDict with alias_generator for camelCase API field mapping
- StrEnum for status fields
- Module-level scheduler instance in src/scheduling/scheduler.py

**From 11-CONTEXT.md:**
- Scheduler interval control (5/10/15/30 minutes)
- Platform toggles (enable/disable SportyBet, Bet9ja, BetPawa)
- Start/stop control (pause and resume scheduler)
- Settings must persist across page refreshes and server restarts (database-backed)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Settings model and migration</name>
  <files>src/db/models/settings.py, src/db/models/__init__.py, alembic/versions/xxx_add_settings_table.py</files>
  <action>
Create a Settings model for scraping configuration:
- Single-row settings table pattern (id=1 singleton)
- Fields: id (Integer PK), scrape_interval_minutes (Integer, default 5), enabled_platforms (JSON array of platform slugs, default ["sportybet", "betpawa", "bet9ja"]), created_at (DateTime), updated_at (DateTime with onupdate)
- Use Mapped[] + mapped_column() pattern consistent with other models
- Add Settings to src/db/models/__init__.py exports

Create Alembic migration:
- Use `alembic revision --autogenerate -m "add settings table"` pattern
- Insert default row with id=1 in upgrade() using op.execute()
- Delete row in downgrade()

Do NOT use environment variables for interval anymore - read from database. The SCRAPE_INTERVAL_MINUTES env var will be deprecated.
  </action>
  <verify>
1. `alembic upgrade head` completes without errors
2. Query shows settings row exists: `SELECT * FROM settings WHERE id = 1`
3. Model imports work: `from src.db.models import Settings`
  </verify>
  <done>
- Settings model created with all fields
- Migration created and runs successfully
- Default settings row inserted with id=1
- Model exported from __init__.py
  </done>
</task>

<task type="auto">
  <name>Task 2: Create settings API endpoints</name>
  <files>src/api/schemas/settings.py, src/api/schemas/__init__.py, src/api/routes/settings.py, src/api/routes/scheduler.py, src/api/app.py, src/scheduling/scheduler.py, src/scheduling/jobs.py</files>
  <action>
Create Pydantic schemas (src/api/schemas/settings.py):
- SettingsResponse: scrape_interval_minutes (int), enabled_platforms (list[str]), updated_at (datetime | None)
- SettingsUpdate: scrape_interval_minutes (int | None, ge=1, le=60), enabled_platforms (list[str] | None)
- Use ConfigDict with alias_generator for camelCase

Create settings routes (src/api/routes/settings.py):
- GET /api/settings - Returns current settings (fetch from db, create default if not exists)
- PUT /api/settings - Updates settings (partial update, only provided fields)

Add scheduler control endpoints to existing scheduler routes:
- POST /api/scheduler/pause - Pause the scheduler (scheduler.pause())
- POST /api/scheduler/resume - Resume the scheduler (scheduler.resume())
- Update GET /api/scheduler/status to include `paused` boolean field in response

Modify scheduler.py:
- Add get_settings() async function that fetches Settings from DB
- Add update_scheduler_interval() function that reschedules the job with new interval
- Remove SCRAPE_INTERVAL_MINUTES env var usage - read from database

Modify jobs.py:
- In scrape_all_platforms(), check enabled_platforms from settings before scraping
- Only scrape platforms that are enabled in settings
- Pass enabled platforms list to orchestrator.scrape_with_progress()

Register settings router in app.py.
Re-export schemas from src/api/schemas/__init__.py.

IMPORTANT: APScheduler's pause()/resume() methods exist on the scheduler instance. The scheduler also has reschedule_job() for changing intervals at runtime.
  </action>
  <verify>
1. `curl http://localhost:8000/api/settings` returns settings JSON
2. `curl -X PUT http://localhost:8000/api/settings -H "Content-Type: application/json" -d '{"scrapeIntervalMinutes": 10}'` updates interval
3. `curl -X POST http://localhost:8000/api/scheduler/pause` pauses scheduler
4. `curl http://localhost:8000/api/scheduler/status` shows paused=true
5. `curl -X POST http://localhost:8000/api/scheduler/resume` resumes scheduler
6. Manual trigger with one platform disabled only scrapes enabled platforms
  </verify>
  <done>
- GET /api/settings returns current configuration
- PUT /api/settings updates interval and/or enabled platforms
- POST /api/scheduler/pause stops job execution
- POST /api/scheduler/resume restarts job execution
- GET /api/scheduler/status includes paused boolean
- Scheduled jobs respect enabled_platforms filter
- Interval changes take effect on next scheduled run
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Settings table exists with default row
- [ ] All endpoints return correct responses
- [ ] Scheduler pause/resume works correctly
- [ ] Platform filtering respected during scrapes
- [ ] No TypeScript/Python errors
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Settings persist across server restarts (database-backed)
- Scheduler control functional via API
</success_criteria>

<output>
After completion, create `.planning/phases/11-settings-page/11-01-SUMMARY.md`
</output>
