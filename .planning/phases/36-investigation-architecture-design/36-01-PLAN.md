---
phase: 36-investigation-architecture-design
plan: 01
type: execute
---

<objective>
Profile current scraping bottlenecks and design event-centric coordination architecture for v1.7.

Purpose: Understand what's actually slow before redesigning, then produce a blueprint that drives Phases 37-42 implementation.
Output: ARCHITECTURE-DESIGN.md with profiling results, rate limit findings, and EventCoordinator design.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-investigation-architecture-design/36-CONTEXT.md

**Current scraping code:**
@src/scraping/orchestrator.py
@src/scraping/competitor_events.py
@src/scraping/clients/betpawa.py
@src/scraping/clients/sportybet.py
@src/scraping/clients/bet9ja.py

**Prior relevant phases:**
@.planning/phases/33-detailed-per-platform-progress/33-01-SUMMARY.md (SSE progress)
@.planning/phases/34-investigation-matching-audit/34-01-SUMMARY.md (matching audit methodology)

**Key patterns from STATE.md:**
- Fetch-then-store pattern for async scraping (Phase 1: API parallel, Phase 2: DB sequential)
- AsyncSession cannot be shared across concurrent asyncio tasks
- Per-platform SSE events exist (v1.5)

**Phase 36 vision (from CONTEXT.md):**
1. Parallel discovery → Merge event universe → Priority queue → Per-event multi-bookmaker scraping
2. Priority: Start time urgency first, then bookmaker coverage count (3 > BP+1 > 2 > 1)
3. Observability needs fresh design for event-centric flow
</context>

<tasks>

<task type="auto">
  <name>Task 1: Profile current scraping flow with timing instrumentation</name>
  <files>.planning/phases/36-investigation-architecture-design/ARCHITECTURE-DESIGN.md</files>
  <action>
Run a manual scrape cycle and collect timing data for each phase:

1. **Trigger scrape via API:**
   ```bash
   curl -X POST http://localhost:8000/api/scrape/start
   ```
   Or use the existing scheduler if running.

2. **Collect timing from logs** (structlog already emits timing):
   - BetPawa competition discovery duration
   - BetPawa event scraping duration (total + per-competition average)
   - BetPawa DB storage duration
   - SportyBet scraping duration
   - Bet9ja scraping duration
   - Total scrape cycle time

3. **Identify bottlenecks:**
   - Which phase takes longest?
   - Where is time spent: API calls vs DB writes?
   - Current semaphore limits (5 competitions, 30 events, 10 tournaments)

4. **Document in ARCHITECTURE-DESIGN.md:**
   Start the file with a "## Current State Profiling" section containing:
   - Timing breakdown table
   - Identified bottlenecks (ranked by impact)
   - Current architecture diagram (text-based)

Note: This is observational profiling using existing logs, not adding new instrumentation. If backend isn't running, document expected bottlenecks from code review of orchestrator.py (lines 313-656 show the flow).
  </action>
  <verify>ARCHITECTURE-DESIGN.md exists with "## Current State Profiling" section containing timing data or code-based analysis</verify>
  <done>Profiling section documents current timing breakdown and bottleneck ranking</done>
</task>

<task type="auto">
  <name>Task 2: Investigate API rate limits for each bookmaker</name>
  <files>.planning/phases/36-investigation-architecture-design/ARCHITECTURE-DESIGN.md</files>
  <action>
Investigate rate limiting behavior for each bookmaker API:

1. **BetPawa:**
   - Current semaphore: 5 concurrent competitions, 30 concurrent events
   - Test: Increase semaphore briefly, observe response times/errors
   - Document: Max safe concurrency, any explicit rate limit headers

2. **SportyBet:**
   - Current semaphore: 30 concurrent events (fetch_event calls)
   - Test: Check response headers for rate limit info (X-RateLimit-*, Retry-After)
   - Document: Observed limits, recommended safe concurrency

3. **Bet9ja:**
   - Current semaphore: 10 concurrent tournaments
   - Has 50ms delay between requests (line 1363)
   - Document: Why delay exists, observed behavior

**Add to ARCHITECTURE-DESIGN.md:**
Create "## Rate Limit Investigation" section with:
- Per-platform rate limit findings table
- Recommended max concurrency per platform
- Any headers/error codes that indicate throttling
- Safe operating parameters for parallel scraping

If unable to run live tests, document from code review: current limits, any rate limit handling code, response patterns observed in logs.
  </action>
  <verify>ARCHITECTURE-DESIGN.md contains "## Rate Limit Investigation" section with per-platform concurrency recommendations</verify>
  <done>Rate limits documented with safe concurrency recommendations for each platform</done>
</task>

<task type="auto">
  <name>Task 3: Design EventCoordinator architecture for Phases 37-42</name>
  <files>.planning/phases/36-investigation-architecture-design/ARCHITECTURE-DESIGN.md</files>
  <action>
Design the new event-centric scraping architecture based on profiling and 36-CONTEXT.md vision.

**1. EventCoordinator Design (Phase 37 scope):**
- Purpose: Coordinate event-centric scraping across all bookmakers
- Key abstractions:
  - `EventCoordinator` class with SR ID collection and priority queue
  - `ScrapeBatch` representing a set of SR IDs to scrape together
  - Priority ordering: start_time ASC, bookmaker_count DESC

**2. SR ID Parallel Scraping (Phase 38 scope):**
- For each SR ID in batch:
  - Spawn parallel tasks for BetPawa, SportyBet, Bet9ja
  - Use platform-specific semaphores from rate limit findings
  - Collect results with timing

**3. Batch DB Storage (Phase 39 scope):**
- Maintain fetch-then-store pattern (proven in v1.1)
- Bulk inserts using SQLAlchemy executemany
- Per-event status tracking (which bookmakers have data)

**4. Observability Design:**
- SSE events: BATCH_START, EVENT_SCRAPED, BATCH_COMPLETE
- Include: sr_id, platforms_scraped, platforms_pending, timing
- UI can show per-event progress, not just per-platform

**Add to ARCHITECTURE-DESIGN.md:**
- "## EventCoordinator Architecture" with class/interface outline
- "## Priority Queue Design" with ordering algorithm
- "## Per-Event Parallel Scraping" with pseudocode
- "## Observability Design" with SSE event types
- "## Phase Mapping" table linking each section to Phase 37-42

Keep designs practical and specific enough to drive implementation. Include data structures, key methods, and flow diagrams (text-based).
  </action>
  <verify>ARCHITECTURE-DESIGN.md contains EventCoordinator design, priority queue algorithm, and phase mapping table</verify>
  <done>Architecture design complete with practical blueprints for Phases 37-42</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] ARCHITECTURE-DESIGN.md exists in phase directory
- [ ] Contains profiling results or code-based analysis
- [ ] Contains rate limit findings with recommendations
- [ ] Contains EventCoordinator design with priority queue
- [ ] Contains observability design for event-centric flow
- [ ] Contains phase mapping linking design sections to Phases 37-42
- [ ] Designs are practical and actionable (not abstract)
</verification>

<success_criteria>
- All tasks completed
- ARCHITECTURE-DESIGN.md provides clear blueprint for v1.7 implementation
- Phase 37-42 scope is informed by this design
- No code changes (investigation/design only per 36-CONTEXT.md boundaries)
</success_criteria>

<output>
After completion, create `.planning/phases/36-investigation-architecture-design/36-01-SUMMARY.md`:

# Phase 36 Plan 01: Investigation & Architecture Design Summary

**[One-liner about what was delivered]**

## Accomplishments

- Profiled current scraping timing and bottlenecks
- Investigated rate limits for all 3 bookmaker APIs
- Designed EventCoordinator architecture for event-centric scraping
- Mapped design sections to Phases 37-42 implementation

## Files Created/Modified

- `.planning/phases/36-investigation-architecture-design/ARCHITECTURE-DESIGN.md` - Full architecture design

## Decisions Made

- [Key architecture decisions]
- [Concurrency limits chosen]
- [Priority queue algorithm selected]

## Issues Encountered

[Any blockers or unknowns discovered]

## Next Phase Readiness

Ready for Phase 37: Event Coordination Layer implementation.
Design doc serves as implementation spec.
</output>
